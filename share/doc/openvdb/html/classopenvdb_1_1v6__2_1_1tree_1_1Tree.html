<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: Tree&lt; _RootNodeType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">6.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v6__2.html">v6_2</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v6__2_1_1tree.html">tree</a></li><li class="navelem"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classopenvdb_1_1v6__2_1_1tree_1_1Tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Tree&lt; _RootNodeType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Tree_8h_source.html">Tree.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html">TreeBase</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v6__2_1_1tree_1_1Tree_1_1DeallocateNodes.html">DeallocateNodes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v6__2_1_1tree_1_1Tree_1_1ValueConverter.html">ValueConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v6__2_1_1tree_1_1Tree_1_1ValueConverter.html#a3391e452092dc3f47fe353a89ba0361e">ValueConverter&lt;T&gt;::Type</a> is the type of a tree having the same hierarchy as this tree but a different value type, T.  <a href="structopenvdb_1_1v6__2_1_1tree_1_1Tree_1_1ValueConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a52a147bfa3994182e5f9d5780ae55513"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a52a147bfa3994182e5f9d5780ae55513">Ptr</a> = <a class="el" href="namespaceopenvdb_1_1v6__2.html#ad71c1f3b8d46b57fd328d48cee283c1f">SharedPtr</a>&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> &gt;</td></tr>
<tr class="separator:a52a147bfa3994182e5f9d5780ae55513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b83fb8c1bb45cc2888847275366120"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#aa9b83fb8c1bb45cc2888847275366120">ConstPtr</a> = <a class="el" href="namespaceopenvdb_1_1v6__2.html#ad71c1f3b8d46b57fd328d48cee283c1f">SharedPtr</a>&lt; const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> &gt;</td></tr>
<tr class="separator:aa9b83fb8c1bb45cc2888847275366120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfd3918f8d5734228a8a97392a91176"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2bfd3918f8d5734228a8a97392a91176">RootNodeType</a> = _RootNodeType</td></tr>
<tr class="separator:a2bfd3918f8d5734228a8a97392a91176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9575d20614e2fac00e43c5fd4fd6f32b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> = typename RootNodeType::ValueType</td></tr>
<tr class="separator:a9575d20614e2fac00e43c5fd4fd6f32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcdb403b52d24b40a88f9d747d1d7ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a7dcdb403b52d24b40a88f9d747d1d7ca">BuildType</a> = typename RootNodeType::BuildType</td></tr>
<tr class="separator:a7dcdb403b52d24b40a88f9d747d1d7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69afaa4f94a67ce2f7d0b18b339291e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad69afaa4f94a67ce2f7d0b18b339291e">LeafNodeType</a> = typename RootNodeType::LeafNodeType</td></tr>
<tr class="separator:ad69afaa4f94a67ce2f7d0b18b339291e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccc5d0e86ce5b20fe01cb1ab2c897fe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a6ccc5d0e86ce5b20fe01cb1ab2c897fe">ValueAllIter</a> = <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeValueIteratorBase.html">TreeValueIteratorBase</a>&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ValueAllIter &gt;</td></tr>
<tr class="separator:a6ccc5d0e86ce5b20fe01cb1ab2c897fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb945a8d6efebff61e309908fb87bc0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2bb945a8d6efebff61e309908fb87bc0">ValueAllCIter</a> = <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeValueIteratorBase.html">TreeValueIteratorBase</a>&lt; const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ValueAllCIter &gt;</td></tr>
<tr class="separator:a2bb945a8d6efebff61e309908fb87bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe548862b5e057f0cea00b94e00809bf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#afe548862b5e057f0cea00b94e00809bf">ValueOnIter</a> = <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeValueIteratorBase.html">TreeValueIteratorBase</a>&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ValueOnIter &gt;</td></tr>
<tr class="separator:afe548862b5e057f0cea00b94e00809bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afd976ee17f253e8f5b449115507c78"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a7afd976ee17f253e8f5b449115507c78">ValueOnCIter</a> = <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeValueIteratorBase.html">TreeValueIteratorBase</a>&lt; const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ValueOnCIter &gt;</td></tr>
<tr class="separator:a7afd976ee17f253e8f5b449115507c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15dad3a20f9ca8647f21cb8394fc1847"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a15dad3a20f9ca8647f21cb8394fc1847">ValueOffIter</a> = <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeValueIteratorBase.html">TreeValueIteratorBase</a>&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ValueOffIter &gt;</td></tr>
<tr class="separator:a15dad3a20f9ca8647f21cb8394fc1847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183496e56dd4a8c98c7b85e2b2d58677"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a183496e56dd4a8c98c7b85e2b2d58677">ValueOffCIter</a> = <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeValueIteratorBase.html">TreeValueIteratorBase</a>&lt; const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ValueOffCIter &gt;</td></tr>
<tr class="separator:a183496e56dd4a8c98c7b85e2b2d58677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5863d8ed73c4bb7a064b678843cfce2d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a5863d8ed73c4bb7a064b678843cfce2d">NodeIter</a> = <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1NodeIteratorBase.html">NodeIteratorBase</a>&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ChildOnIter &gt;</td></tr>
<tr class="memdesc:a5863d8ed73c4bb7a064b678843cfce2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over all nodes in this tree.  <a href="#a5863d8ed73c4bb7a064b678843cfce2d">More...</a><br /></td></tr>
<tr class="separator:a5863d8ed73c4bb7a064b678843cfce2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf558d7273da3c5badff79938c9b43e2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#acf558d7273da3c5badff79938c9b43e2">NodeCIter</a> = <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1NodeIteratorBase.html">NodeIteratorBase</a>&lt; const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ChildOnCIter &gt;</td></tr>
<tr class="memdesc:acf558d7273da3c5badff79938c9b43e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over all nodes in this tree.  <a href="#acf558d7273da3c5badff79938c9b43e2">More...</a><br /></td></tr>
<tr class="separator:acf558d7273da3c5badff79938c9b43e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa71c9eea9da1f0718ecd069e34823f3f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#aa71c9eea9da1f0718ecd069e34823f3f">LeafIter</a> = <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1LeafIteratorBase.html">LeafIteratorBase</a>&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ChildOnIter &gt;</td></tr>
<tr class="memdesc:aa71c9eea9da1f0718ecd069e34823f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over all leaf nodes in this tree.  <a href="#aa71c9eea9da1f0718ecd069e34823f3f">More...</a><br /></td></tr>
<tr class="separator:aa71c9eea9da1f0718ecd069e34823f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cc6e43580444de39db347e1c0a9dee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a30cc6e43580444de39db347e1c0a9dee">LeafCIter</a> = <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1LeafIteratorBase.html">LeafIteratorBase</a>&lt; const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ChildOnCIter &gt;</td></tr>
<tr class="memdesc:a30cc6e43580444de39db347e1c0a9dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over all leaf nodes in this tree.  <a href="#a30cc6e43580444de39db347e1c0a9dee">More...</a><br /></td></tr>
<tr class="separator:a30cc6e43580444de39db347e1c0a9dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3dee5770ede29888f2c0136bbd7f5a95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a3dee5770ede29888f2c0136bbd7f5a95">Tree</a> ()</td></tr>
<tr class="separator:a3dee5770ede29888f2c0136bbd7f5a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddc9d21426bff9261068aec40d85b39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a4ddc9d21426bff9261068aec40d85b39">operator=</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> &amp;)=delete</td></tr>
<tr class="separator:a4ddc9d21426bff9261068aec40d85b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176bf2364d34c17e2e02eb44a21c520d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a176bf2364d34c17e2e02eb44a21c520d">Tree</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> &amp;other)</td></tr>
<tr class="memdesc:a176bf2364d34c17e2e02eb44a21c520d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy constructor.  <a href="#a176bf2364d34c17e2e02eb44a21c520d">More...</a><br /></td></tr>
<tr class="separator:a176bf2364d34c17e2e02eb44a21c520d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213c0ce777bcd4328500431d3231a446"><td class="memTemplParams" colspan="2">template&lt;typename OtherRootType &gt; </td></tr>
<tr class="memitem:a213c0ce777bcd4328500431d3231a446"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a213c0ce777bcd4328500431d3231a446">Tree</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; OtherRootType &gt; &amp;other)</td></tr>
<tr class="memdesc:a213c0ce777bcd4328500431d3231a446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value conversion deep copy constructor.  <a href="#a213c0ce777bcd4328500431d3231a446">More...</a><br /></td></tr>
<tr class="separator:a213c0ce777bcd4328500431d3231a446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae3bd6c1599f80a0f3b518945195b9e"><td class="memTemplParams" colspan="2">template&lt;typename OtherTreeType &gt; </td></tr>
<tr class="memitem:adae3bd6c1599f80a0f3b518945195b9e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#adae3bd6c1599f80a0f3b518945195b9e">Tree</a> (const OtherTreeType &amp;other, const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;inactiveValue, const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;activeValue, <a class="el" href="classopenvdb_1_1v6__2_1_1TopologyCopy.html">TopologyCopy</a>)</td></tr>
<tr class="memdesc:adae3bd6c1599f80a0f3b518945195b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topology copy constructor from a tree of a different type.  <a href="#adae3bd6c1599f80a0f3b518945195b9e">More...</a><br /></td></tr>
<tr class="separator:adae3bd6c1599f80a0f3b518945195b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab198c466f09f12bcd4d14367068450c6"><td class="memTemplParams" colspan="2">template&lt;typename OtherTreeType &gt; </td></tr>
<tr class="memitem:ab198c466f09f12bcd4d14367068450c6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ab198c466f09f12bcd4d14367068450c6">Tree</a> (const OtherTreeType &amp;other, const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a1a0b2540a4e2d53598c52a84c2974245">background</a>, <a class="el" href="classopenvdb_1_1v6__2_1_1TopologyCopy.html">TopologyCopy</a>)</td></tr>
<tr class="memdesc:ab198c466f09f12bcd4d14367068450c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topology copy constructor from a tree of a different type.  <a href="#ab198c466f09f12bcd4d14367068450c6">More...</a><br /></td></tr>
<tr class="separator:ab198c466f09f12bcd4d14367068450c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65bce1b639b04c7f8004f54571e1453"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ae65bce1b639b04c7f8004f54571e1453">Tree</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a1a0b2540a4e2d53598c52a84c2974245">background</a>)</td></tr>
<tr class="memdesc:ae65bce1b639b04c7f8004f54571e1453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty tree constructor.  <a href="#ae65bce1b639b04c7f8004f54571e1453">More...</a><br /></td></tr>
<tr class="separator:ae65bce1b639b04c7f8004f54571e1453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0489c0d8a3abb2f8a066991ed559426"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ae0489c0d8a3abb2f8a066991ed559426">~Tree</a> () override</td></tr>
<tr class="separator:ae0489c0d8a3abb2f8a066991ed559426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956efa074c97b4e8e3fe63b0832be5f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#ab5e4dbbad02cb8050f56d4c9a9c8c937">TreeBase::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a956efa074c97b4e8e3fe63b0832be5f0">copy</a> () const override</td></tr>
<tr class="memdesc:a956efa074c97b4e8e3fe63b0832be5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to a deep copy of this tree.  <a href="#a956efa074c97b4e8e3fe63b0832be5f0">More...</a><br /></td></tr>
<tr class="separator:a956efa074c97b4e8e3fe63b0832be5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf5c7a62c61dc964ae5e972d15a7470"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v6__2.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#aecf5c7a62c61dc964ae5e972d15a7470">valueType</a> () const override</td></tr>
<tr class="memdesc:aecf5c7a62c61dc964ae5e972d15a7470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the type of a voxel's value (e.g., "float" or "vec3d")  <a href="#aecf5c7a62c61dc964ae5e972d15a7470">More...</a><br /></td></tr>
<tr class="separator:aecf5c7a62c61dc964ae5e972d15a7470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1417546ed9bc3e5a3daa3f2bde001a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceopenvdb_1_1v6__2.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a8a1417546ed9bc3e5a3daa3f2bde001a">type</a> () const override</td></tr>
<tr class="memdesc:a8a1417546ed9bc3e5a3daa3f2bde001a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of this type of tree.  <a href="#a8a1417546ed9bc3e5a3daa3f2bde001a">More...</a><br /></td></tr>
<tr class="separator:a8a1417546ed9bc3e5a3daa3f2bde001a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffa08696ac4169c485f707fff7a5861"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a4ffa08696ac4169c485f707fff7a5861">operator==</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> &amp;) const</td></tr>
<tr class="separator:a4ffa08696ac4169c485f707fff7a5861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc5125f182645c0dc5f473440619b10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a3dc5125f182645c0dc5f473440619b10">operator!=</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> &amp;) const</td></tr>
<tr class="separator:a3dc5125f182645c0dc5f473440619b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0533c7394aa18dbf9c65d6573cf0656f"><td class="memTemplParams" colspan="2">template&lt;typename OtherRootNodeType &gt; </td></tr>
<tr class="memitem:a0533c7394aa18dbf9c65d6573cf0656f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a0533c7394aa18dbf9c65d6573cf0656f">hasSameTopology</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; OtherRootNodeType &gt; &amp;other) const</td></tr>
<tr class="memdesc:a0533c7394aa18dbf9c65d6573cf0656f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the given tree has the same node and active value topology as this tree, whether or not it has the same <code>ValueType</code>.  <a href="#a0533c7394aa18dbf9c65d6573cf0656f">More...</a><br /></td></tr>
<tr class="separator:a0533c7394aa18dbf9c65d6573cf0656f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33df3a47879d72c499c446e0d9fedea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ac33df3a47879d72c499c446e0d9fedea">evalLeafBoundingBox</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox) const override</td></tr>
<tr class="memdesc:ac33df3a47879d72c499c446e0d9fedea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return in <em>bbox</em> the axis-aligned bounding box of all leaf nodes and active tiles.  <a href="#ac33df3a47879d72c499c446e0d9fedea">More...</a><br /></td></tr>
<tr class="separator:ac33df3a47879d72c499c446e0d9fedea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be8f5d220e6c9f76f6f443bba38d7af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a0be8f5d220e6c9f76f6f443bba38d7af">evalActiveVoxelBoundingBox</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox) const override</td></tr>
<tr class="memdesc:a0be8f5d220e6c9f76f6f443bba38d7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return in <em>bbox</em> the axis-aligned bounding box of all active voxels and tiles.  <a href="#a0be8f5d220e6c9f76f6f443bba38d7af">More...</a><br /></td></tr>
<tr class="separator:a0be8f5d220e6c9f76f6f443bba38d7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb42ab1115f04d94d3d59da5c79c6e90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#adb42ab1115f04d94d3d59da5c79c6e90">evalActiveVoxelDim</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;dim) const override</td></tr>
<tr class="memdesc:adb42ab1115f04d94d3d59da5c79c6e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return in <em>dim</em> the dimensions of the axis-aligned bounding box of all active voxels. This is a tighter bounding box than the leaf node bounding box.  <a href="#adb42ab1115f04d94d3d59da5c79c6e90">More...</a><br /></td></tr>
<tr class="separator:adb42ab1115f04d94d3d59da5c79c6e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8db9086dcfece9d64eab53bccdd30cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ac8db9086dcfece9d64eab53bccdd30cd">evalLeafDim</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;dim) const override</td></tr>
<tr class="memdesc:ac8db9086dcfece9d64eab53bccdd30cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return in <em>dim</em> the dimensions of the axis-aligned bounding box of all leaf nodes.  <a href="#ac8db9086dcfece9d64eab53bccdd30cd">More...</a><br /></td></tr>
<tr class="separator:ac8db9086dcfece9d64eab53bccdd30cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007631c53f0e3e44457f2f72fd22323d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a007631c53f0e3e44457f2f72fd22323d">readTopology</a> (std::istream &amp;, bool saveFloatAsHalf=false) override</td></tr>
<tr class="memdesc:a007631c53f0e3e44457f2f72fd22323d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the tree topology from a stream.  <a href="#a007631c53f0e3e44457f2f72fd22323d">More...</a><br /></td></tr>
<tr class="separator:a007631c53f0e3e44457f2f72fd22323d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aba66443ac6b0c138ae069f85d9d804"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a1aba66443ac6b0c138ae069f85d9d804">writeTopology</a> (std::ostream &amp;, bool saveFloatAsHalf=false) const override</td></tr>
<tr class="memdesc:a1aba66443ac6b0c138ae069f85d9d804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the tree topology to a stream.  <a href="#a1aba66443ac6b0c138ae069f85d9d804">More...</a><br /></td></tr>
<tr class="separator:a1aba66443ac6b0c138ae069f85d9d804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67a4ef3e29a1d58159e18cb0fce0515"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad67a4ef3e29a1d58159e18cb0fce0515">readBuffers</a> (std::istream &amp;, bool saveFloatAsHalf=false) override</td></tr>
<tr class="memdesc:ad67a4ef3e29a1d58159e18cb0fce0515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read all data buffers for this tree.  <a href="#ad67a4ef3e29a1d58159e18cb0fce0515">More...</a><br /></td></tr>
<tr class="separator:ad67a4ef3e29a1d58159e18cb0fce0515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347a003931da1fe21c904f52322a3a00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a347a003931da1fe21c904f52322a3a00">readBuffers</a> (std::istream &amp;, const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;, bool saveFloatAsHalf=false) override</td></tr>
<tr class="memdesc:a347a003931da1fe21c904f52322a3a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read all of this tree's data buffers that intersect the given bounding box.  <a href="#a347a003931da1fe21c904f52322a3a00">More...</a><br /></td></tr>
<tr class="separator:a347a003931da1fe21c904f52322a3a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0416e0758e74661727eb9d3c46b528"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#aaa0416e0758e74661727eb9d3c46b528">readNonresidentBuffers</a> () const override</td></tr>
<tr class="memdesc:aaa0416e0758e74661727eb9d3c46b528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read all of this tree's data buffers that are not yet resident in memory (because delayed loading is in effect).  <a href="#aaa0416e0758e74661727eb9d3c46b528">More...</a><br /></td></tr>
<tr class="separator:aaa0416e0758e74661727eb9d3c46b528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a50e37a4ebc77e9ed095c689ab694f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a1a50e37a4ebc77e9ed095c689ab694f3">writeBuffers</a> (std::ostream &amp;, bool saveFloatAsHalf=false) const override</td></tr>
<tr class="memdesc:a1a50e37a4ebc77e9ed095c689ab694f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out all data buffers for this tree.  <a href="#a1a50e37a4ebc77e9ed095c689ab694f3">More...</a><br /></td></tr>
<tr class="separator:a1a50e37a4ebc77e9ed095c689ab694f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a2493ba6f01768bfd929f8e9e6e21c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#aa0a2493ba6f01768bfd929f8e9e6e21c">print</a> (std::ostream &amp;os=std::cout, int verboseLevel=1) const override</td></tr>
<tr class="memdesc:aa0a2493ba6f01768bfd929f8e9e6e21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print statistics, memory usage and other information about this tree.  <a href="#aa0a2493ba6f01768bfd929f8e9e6e21c">More...</a><br /></td></tr>
<tr class="separator:aa0a2493ba6f01768bfd929f8e9e6e21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2efbad063f9f8cd68f260ebf06f9ad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v6__2.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#af2efbad063f9f8cd68f260ebf06f9ad8">treeDepth</a> () const override</td></tr>
<tr class="memdesc:af2efbad063f9f8cd68f260ebf06f9ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the depth of this tree.  <a href="#af2efbad063f9f8cd68f260ebf06f9ad8">More...</a><br /></td></tr>
<tr class="separator:af2efbad063f9f8cd68f260ebf06f9ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee8f6c345a7611cf70f10361c6248f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v6__2.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a5ee8f6c345a7611cf70f10361c6248f0">leafCount</a> () const override</td></tr>
<tr class="memdesc:a5ee8f6c345a7611cf70f10361c6248f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of leaf nodes.  <a href="#a5ee8f6c345a7611cf70f10361c6248f0">More...</a><br /></td></tr>
<tr class="separator:a5ee8f6c345a7611cf70f10361c6248f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea494a915911bbde5e5a9eb26d89bec1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v6__2.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#aea494a915911bbde5e5a9eb26d89bec1">nonLeafCount</a> () const override</td></tr>
<tr class="memdesc:aea494a915911bbde5e5a9eb26d89bec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of non-leaf nodes.  <a href="#aea494a915911bbde5e5a9eb26d89bec1">More...</a><br /></td></tr>
<tr class="separator:aea494a915911bbde5e5a9eb26d89bec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59650f93e1ae386d3e4d51c3ee11c447"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v6__2.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a59650f93e1ae386d3e4d51c3ee11c447">activeLeafVoxelCount</a> () const override</td></tr>
<tr class="memdesc:a59650f93e1ae386d3e4d51c3ee11c447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of active voxels stored in leaf nodes.  <a href="#a59650f93e1ae386d3e4d51c3ee11c447">More...</a><br /></td></tr>
<tr class="separator:a59650f93e1ae386d3e4d51c3ee11c447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689a5c4f6bbbb15831a4f53438e63929"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v6__2.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a689a5c4f6bbbb15831a4f53438e63929">inactiveLeafVoxelCount</a> () const override</td></tr>
<tr class="memdesc:a689a5c4f6bbbb15831a4f53438e63929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of inactive voxels stored in leaf nodes.  <a href="#a689a5c4f6bbbb15831a4f53438e63929">More...</a><br /></td></tr>
<tr class="separator:a689a5c4f6bbbb15831a4f53438e63929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6539f03b2b21ca05568d6bc8f1de9584"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v6__2.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a6539f03b2b21ca05568d6bc8f1de9584">activeVoxelCount</a> () const override</td></tr>
<tr class="memdesc:a6539f03b2b21ca05568d6bc8f1de9584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of active voxels.  <a href="#a6539f03b2b21ca05568d6bc8f1de9584">More...</a><br /></td></tr>
<tr class="separator:a6539f03b2b21ca05568d6bc8f1de9584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f9cac4988865277566d8d71ef85365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v6__2.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a62f9cac4988865277566d8d71ef85365">inactiveVoxelCount</a> () const override</td></tr>
<tr class="memdesc:a62f9cac4988865277566d8d71ef85365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of inactive voxels within the bounding box of all active voxels.  <a href="#a62f9cac4988865277566d8d71ef85365">More...</a><br /></td></tr>
<tr class="separator:a62f9cac4988865277566d8d71ef85365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a3c47b3840bf275481e77ac65bb047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v6__2.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a88a3c47b3840bf275481e77ac65bb047">activeTileCount</a> () const override</td></tr>
<tr class="memdesc:a88a3c47b3840bf275481e77ac65bb047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of active tiles.  <a href="#a88a3c47b3840bf275481e77ac65bb047">More...</a><br /></td></tr>
<tr class="separator:a88a3c47b3840bf275481e77ac65bb047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f97e5be1f39947eb39b82285586d52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a26f97e5be1f39947eb39b82285586d52">evalMinMax</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;min, <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;max) const</td></tr>
<tr class="memdesc:a26f97e5be1f39947eb39b82285586d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum and maximum active values in this tree.  <a href="#a26f97e5be1f39947eb39b82285586d52">More...</a><br /></td></tr>
<tr class="separator:a26f97e5be1f39947eb39b82285586d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237bd8c635a56232570358f99e922328"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v6__2.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a237bd8c635a56232570358f99e922328">memUsage</a> () const override</td></tr>
<tr class="memdesc:a237bd8c635a56232570358f99e922328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total amount of memory in bytes occupied by this tree.  <a href="#a237bd8c635a56232570358f99e922328">More...</a><br /></td></tr>
<tr class="separator:a237bd8c635a56232570358f99e922328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96003dd5795749675766804a5a618f9b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a96003dd5795749675766804a5a618f9b">getValue</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memdesc:a96003dd5795749675766804a5a618f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the voxel at the given coordinates.  <a href="#a96003dd5795749675766804a5a618f9b">More...</a><br /></td></tr>
<tr class="separator:a96003dd5795749675766804a5a618f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887eb7998c9926f06eab7de2ee7cf947"><td class="memTemplParams" colspan="2">template&lt;typename AccessT &gt; </td></tr>
<tr class="memitem:a887eb7998c9926f06eab7de2ee7cf947"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a887eb7998c9926f06eab7de2ee7cf947">getValue</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz, AccessT &amp;) const</td></tr>
<tr class="memdesc:a887eb7998c9926f06eab7de2ee7cf947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the voxel at the given coordinates and update the given accessor's node cache.  <a href="#a887eb7998c9926f06eab7de2ee7cf947">More...</a><br /></td></tr>
<tr class="separator:a887eb7998c9926f06eab7de2ee7cf947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c8f00f509936998e0d47be7afd5e3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a03c8f00f509936998e0d47be7afd5e3f">getValueDepth</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memdesc:a03c8f00f509936998e0d47be7afd5e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tree depth (0 = root) at which the value of voxel (x, y, z) resides.  <a href="#a03c8f00f509936998e0d47be7afd5e3f">More...</a><br /></td></tr>
<tr class="separator:a03c8f00f509936998e0d47be7afd5e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3e82eb582914ac6f31f32fea77292f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a7b3e82eb582914ac6f31f32fea77292f">setActiveState</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz, bool on)</td></tr>
<tr class="memdesc:a7b3e82eb582914ac6f31f32fea77292f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the active state of the voxel at the given coordinates but don't change its value.  <a href="#a7b3e82eb582914ac6f31f32fea77292f">More...</a><br /></td></tr>
<tr class="separator:a7b3e82eb582914ac6f31f32fea77292f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ff695beda11ed9ef625a28ce8a5faf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a63ff695beda11ed9ef625a28ce8a5faf">setValueOnly</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a63ff695beda11ed9ef625a28ce8a5faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates but don't change its active state.  <a href="#a63ff695beda11ed9ef625a28ce8a5faf">More...</a><br /></td></tr>
<tr class="separator:a63ff695beda11ed9ef625a28ce8a5faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cf12f28a771762327ba1578bc48e9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad6cf12f28a771762327ba1578bc48e9c">setValueOn</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz)</td></tr>
<tr class="memdesc:ad6cf12f28a771762327ba1578bc48e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the voxel at the given coordinates as active but don't change its value.  <a href="#ad6cf12f28a771762327ba1578bc48e9c">More...</a><br /></td></tr>
<tr class="separator:ad6cf12f28a771762327ba1578bc48e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95653046c85afb743075f139a26df9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ae95653046c85afb743075f139a26df9d">setValueOn</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:ae95653046c85afb743075f139a26df9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates and mark the voxel as active.  <a href="#ae95653046c85afb743075f139a26df9d">More...</a><br /></td></tr>
<tr class="separator:ae95653046c85afb743075f139a26df9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83302a39df403b0b10ffcadac5856916"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a83302a39df403b0b10ffcadac5856916">setValue</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a83302a39df403b0b10ffcadac5856916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates and mark the voxel as active.  <a href="#a83302a39df403b0b10ffcadac5856916">More...</a><br /></td></tr>
<tr class="separator:a83302a39df403b0b10ffcadac5856916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf7e55fdc58f2c5d03395bffe10410e"><td class="memTemplParams" colspan="2">template&lt;typename AccessT &gt; </td></tr>
<tr class="memitem:acbf7e55fdc58f2c5d03395bffe10410e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#acbf7e55fdc58f2c5d03395bffe10410e">setValue</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;value, AccessT &amp;)</td></tr>
<tr class="memdesc:acbf7e55fdc58f2c5d03395bffe10410e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates, mark the voxel as active, and update the given accessor's node cache.  <a href="#acbf7e55fdc58f2c5d03395bffe10410e">More...</a><br /></td></tr>
<tr class="separator:acbf7e55fdc58f2c5d03395bffe10410e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a91d631df8f64f84a0aad7436cb11f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a8a91d631df8f64f84a0aad7436cb11f3">setValueOff</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz)</td></tr>
<tr class="memdesc:a8a91d631df8f64f84a0aad7436cb11f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the voxel at the given coordinates as inactive but don't change its value.  <a href="#a8a91d631df8f64f84a0aad7436cb11f3">More...</a><br /></td></tr>
<tr class="separator:a8a91d631df8f64f84a0aad7436cb11f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a6e7c85d37e7d677eddc3cce8aa11b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a73a6e7c85d37e7d677eddc3cce8aa11b">setValueOff</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a73a6e7c85d37e7d677eddc3cce8aa11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates and mark the voxel as inactive.  <a href="#a73a6e7c85d37e7d677eddc3cce8aa11b">More...</a><br /></td></tr>
<tr class="separator:a73a6e7c85d37e7d677eddc3cce8aa11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6954a428c0ef18a03431f251f4e7d24"><td class="memTemplParams" colspan="2">template&lt;typename ModifyOp &gt; </td></tr>
<tr class="memitem:aa6954a428c0ef18a03431f251f4e7d24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#aa6954a428c0ef18a03431f251f4e7d24">modifyValue</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const ModifyOp &amp;op)</td></tr>
<tr class="memdesc:aa6954a428c0ef18a03431f251f4e7d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to the value of the voxel at the given coordinates and mark the voxel as active.  <a href="#aa6954a428c0ef18a03431f251f4e7d24">More...</a><br /></td></tr>
<tr class="separator:aa6954a428c0ef18a03431f251f4e7d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb69af7e17c3a9a6d6dc360c878448c"><td class="memTemplParams" colspan="2">template&lt;typename ModifyOp &gt; </td></tr>
<tr class="memitem:a5cb69af7e17c3a9a6d6dc360c878448c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a5cb69af7e17c3a9a6d6dc360c878448c">modifyValueAndActiveState</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const ModifyOp &amp;op)</td></tr>
<tr class="memdesc:a5cb69af7e17c3a9a6d6dc360c878448c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to the voxel at the given coordinates.  <a href="#a5cb69af7e17c3a9a6d6dc360c878448c">More...</a><br /></td></tr>
<tr class="separator:a5cb69af7e17c3a9a6d6dc360c878448c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac3a88741d49d74b50c55b9a5371646"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a7ac3a88741d49d74b50c55b9a5371646">probeValue</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz, <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;value) const</td></tr>
<tr class="memdesc:a7ac3a88741d49d74b50c55b9a5371646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the voxel at the given coordinates.  <a href="#a7ac3a88741d49d74b50c55b9a5371646">More...</a><br /></td></tr>
<tr class="separator:a7ac3a88741d49d74b50c55b9a5371646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149d3646dfe8b0ae5f352cea5c1e9cc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a149d3646dfe8b0ae5f352cea5c1e9cc7">isValueOn</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memdesc:a149d3646dfe8b0ae5f352cea5c1e9cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the value at the given coordinates is active.  <a href="#a149d3646dfe8b0ae5f352cea5c1e9cc7">More...</a><br /></td></tr>
<tr class="separator:a149d3646dfe8b0ae5f352cea5c1e9cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae965878865e08511fc2e16abc00b64c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ae965878865e08511fc2e16abc00b64c1">isValueOff</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memdesc:ae965878865e08511fc2e16abc00b64c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the value at the given coordinates is inactive.  <a href="#ae965878865e08511fc2e16abc00b64c1">More...</a><br /></td></tr>
<tr class="separator:ae965878865e08511fc2e16abc00b64c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27c5b1e634724be621234d2653c8eae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ae27c5b1e634724be621234d2653c8eae">hasActiveTiles</a> () const</td></tr>
<tr class="memdesc:ae27c5b1e634724be621234d2653c8eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if this tree has any active tiles.  <a href="#ae27c5b1e634724be621234d2653c8eae">More...</a><br /></td></tr>
<tr class="separator:ae27c5b1e634724be621234d2653c8eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409633b422404c1c7df4e0ffdd02eac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a409633b422404c1c7df4e0ffdd02eac1">clip</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;)</td></tr>
<tr class="memdesc:a409633b422404c1c7df4e0ffdd02eac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all voxels that lie outside the given axis-aligned box to the background.  <a href="#a409633b422404c1c7df4e0ffdd02eac1">More...</a><br /></td></tr>
<tr class="separator:a409633b422404c1c7df4e0ffdd02eac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68f15390dfa328e07ae1a372deb1139"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ae68f15390dfa328e07ae1a372deb1139">clipUnallocatedNodes</a> () override</td></tr>
<tr class="memdesc:ae68f15390dfa328e07ae1a372deb1139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace with background tiles any nodes whose voxel buffers have not yet been allocated.  <a href="#ae68f15390dfa328e07ae1a372deb1139">More...</a><br /></td></tr>
<tr class="separator:ae68f15390dfa328e07ae1a372deb1139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae386cb138ff84e81f8c7d594d4acd851"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v6__2.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ae386cb138ff84e81f8c7d594d4acd851">unallocatedLeafCount</a> () const override</td></tr>
<tr class="memdesc:ae386cb138ff84e81f8c7d594d4acd851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of unallocated leaf nodes residing in this tree.  <a href="#ae386cb138ff84e81f8c7d594d4acd851">More...</a><br /></td></tr>
<tr class="separator:ae386cb138ff84e81f8c7d594d4acd851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb399cd065108e53e7b65612e74372a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#abb399cd065108e53e7b65612e74372a5">denseFill</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox, const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;value, bool active=true)</td></tr>
<tr class="memdesc:abb399cd065108e53e7b65612e74372a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all voxels within a given axis-aligned box to a constant value and ensure that those voxels are all represented at the leaf level.  <a href="#abb399cd065108e53e7b65612e74372a5">More...</a><br /></td></tr>
<tr class="separator:abb399cd065108e53e7b65612e74372a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a2211a02fb606e611d3ff5bbd6f50c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a39a2211a02fb606e611d3ff5bbd6f50c">voxelizeActiveTiles</a> (bool threaded=true)</td></tr>
<tr class="memdesc:a39a2211a02fb606e611d3ff5bbd6f50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Densify active tiles, i.e., replace them with leaf-level active voxels.  <a href="#a39a2211a02fb606e611d3ff5bbd6f50c">More...</a><br /></td></tr>
<tr class="separator:a39a2211a02fb606e611d3ff5bbd6f50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462c7056adc55d8da2cc5828934ff859"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a462c7056adc55d8da2cc5828934ff859">prune</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;tolerance=<a class="el" href="namespaceopenvdb_1_1v6__2.html#a92d064b9b9b524a9db16b22a22293068">zeroVal</a>&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &gt;())</td></tr>
<tr class="memdesc:a462c7056adc55d8da2cc5828934ff859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the memory footprint of this tree by replacing with tiles any nodes whose values are all the same (optionally to within a tolerance) and have the same active state.  <a href="#a462c7056adc55d8da2cc5828934ff859">More...</a><br /></td></tr>
<tr class="separator:a462c7056adc55d8da2cc5828934ff859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c20c22e9a994a30c9640cbe1ec982bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a6c20c22e9a994a30c9640cbe1ec982bc">addLeaf</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad69afaa4f94a67ce2f7d0b18b339291e">LeafNodeType</a> *leaf)</td></tr>
<tr class="memdesc:a6c20c22e9a994a30c9640cbe1ec982bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given leaf node to this tree, creating a new branch if necessary. If a leaf node with the same origin already exists, replace it.  <a href="#a6c20c22e9a994a30c9640cbe1ec982bc">More...</a><br /></td></tr>
<tr class="separator:a6c20c22e9a994a30c9640cbe1ec982bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75454b135a1e19473aa702a90fd00802"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a75454b135a1e19473aa702a90fd00802">addTile</a> (<a class="el" href="namespaceopenvdb_1_1v6__2.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> level, const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;value, bool active)</td></tr>
<tr class="memdesc:a75454b135a1e19473aa702a90fd00802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a tile containing voxel (x, y, z) at the specified tree level, creating a new branch if necessary. Delete any existing lower-level nodes that contain (x, y, z).  <a href="#a75454b135a1e19473aa702a90fd00802">More...</a><br /></td></tr>
<tr class="separator:a75454b135a1e19473aa702a90fd00802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f336548f0b7d3e0debadf68d43602b6"><td class="memTemplParams" colspan="2">template&lt;typename NodeT &gt; </td></tr>
<tr class="memitem:a0f336548f0b7d3e0debadf68d43602b6"><td class="memTemplItemLeft" align="right" valign="top">NodeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a0f336548f0b7d3e0debadf68d43602b6">stealNode</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;value, bool active)</td></tr>
<tr class="memdesc:a0f336548f0b7d3e0debadf68d43602b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the node of type <code>NodeT</code> that contains voxel (x, y, z) and replace it with a tile of the specified value and state. If no such node exists, leave the tree unchanged and return <code>nullptr</code>.  <a href="#a0f336548f0b7d3e0debadf68d43602b6">More...</a><br /></td></tr>
<tr class="separator:a0f336548f0b7d3e0debadf68d43602b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b094186577cde9b7ad1f326389c815f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad69afaa4f94a67ce2f7d0b18b339291e">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a4b094186577cde9b7ad1f326389c815f">touchLeaf</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz)</td></tr>
<tr class="memdesc:a4b094186577cde9b7ad1f326389c815f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, create one that preserves the values and active states of all voxels.  <a href="#a4b094186577cde9b7ad1f326389c815f">More...</a><br /></td></tr>
<tr class="separator:a4b094186577cde9b7ad1f326389c815f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9865f5a8eabf75fc2ad06581e22edcd"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:ae9865f5a8eabf75fc2ad06581e22edcd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ae9865f5a8eabf75fc2ad06581e22edcd">stealNodes</a> (ArrayT &amp;array)</td></tr>
<tr class="memdesc:ae9865f5a8eabf75fc2ad06581e22edcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Steals all nodes of a certain type from the tree and adds them to a container with the following API:  <a href="#ae9865f5a8eabf75fc2ad06581e22edcd">More...</a><br /></td></tr>
<tr class="separator:ae9865f5a8eabf75fc2ad06581e22edcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a8fd1479bd7b61a23884680d5d49e0"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:ac4a8fd1479bd7b61a23884680d5d49e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ac4a8fd1479bd7b61a23884680d5d49e0">stealNodes</a> (ArrayT &amp;array, const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;value, bool state)</td></tr>
<tr class="separator:ac4a8fd1479bd7b61a23884680d5d49e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a644718bb2fb240de962dc3c9a1fdf0dc">empty</a> () const</td></tr>
<tr class="memdesc:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if this tree contains no nodes other than the root node and no tiles other than background tiles.  <a href="#a644718bb2fb240de962dc3c9a1fdf0dc">More...</a><br /></td></tr>
<tr class="separator:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bb3912a3ce86b15842e79d0b421204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>
<tr class="memdesc:ac8bb3912a3ce86b15842e79d0b421204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all tiles from this tree and all nodes other than the root node.  <a href="#ac8bb3912a3ce86b15842e79d0b421204">More...</a><br /></td></tr>
<tr class="separator:ac8bb3912a3ce86b15842e79d0b421204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a9fa1c5dbac50f2d5f406f8842e368"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a24a9fa1c5dbac50f2d5f406f8842e368">clearAllAccessors</a> ()</td></tr>
<tr class="memdesc:a24a9fa1c5dbac50f2d5f406f8842e368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all registered accessors.  <a href="#a24a9fa1c5dbac50f2d5f406f8842e368">More...</a><br /></td></tr>
<tr class="separator:a24a9fa1c5dbac50f2d5f406f8842e368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032258988b41cc4ce0a3b310f45d5d7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1Metadata.html#ace3ea7af32684cd869611506ad3e12e8">Metadata::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a032258988b41cc4ce0a3b310f45d5d7d">getBackgroundValue</a> () const override</td></tr>
<tr class="memdesc:a032258988b41cc4ce0a3b310f45d5d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this tree's background value wrapped as metadata.  <a href="#a032258988b41cc4ce0a3b310f45d5d7d">More...</a><br /></td></tr>
<tr class="separator:a032258988b41cc4ce0a3b310f45d5d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0b2540a4e2d53598c52a84c2974245"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a1a0b2540a4e2d53598c52a84c2974245">background</a> () const</td></tr>
<tr class="memdesc:a1a0b2540a4e2d53598c52a84c2974245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this tree's background value.  <a href="#a1a0b2540a4e2d53598c52a84c2974245">More...</a><br /></td></tr>
<tr class="separator:a1a0b2540a4e2d53598c52a84c2974245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad588c2e8ac949143607f6455b86cf40b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad588c2e8ac949143607f6455b86cf40b">getIndexRange</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox) const override</td></tr>
<tr class="memdesc:ad588c2e8ac949143607f6455b86cf40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Min and max are both inclusive.  <a href="#ad588c2e8ac949143607f6455b86cf40b">More...</a><br /></td></tr>
<tr class="separator:ad588c2e8ac949143607f6455b86cf40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba5f332b68e4a1ebba9dbf4b95ec807"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2ba5f332b68e4a1ebba9dbf4b95ec807">merge</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> &amp;other, <a class="el" href="namespaceopenvdb_1_1v6__2.html#ade9c95ac55c647839e6f3e9b462c0575">MergePolicy</a>=<a class="el" href="namespaceopenvdb_1_1v6__2.html#ade9c95ac55c647839e6f3e9b462c0575a89c44945b26534bc1d5ede51c342400e">MERGE_ACTIVE_STATES</a>)</td></tr>
<tr class="memdesc:a2ba5f332b68e4a1ebba9dbf4b95ec807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently merge another tree into this tree using one of several schemes.  <a href="#a2ba5f332b68e4a1ebba9dbf4b95ec807">More...</a><br /></td></tr>
<tr class="separator:a2ba5f332b68e4a1ebba9dbf4b95ec807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32b595dbcad270a15ed20df549c946f"><td class="memTemplParams" colspan="2">template&lt;typename OtherRootNodeType &gt; </td></tr>
<tr class="memitem:ac32b595dbcad270a15ed20df549c946f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ac32b595dbcad270a15ed20df549c946f">topologyUnion</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; OtherRootNodeType &gt; &amp;other)</td></tr>
<tr class="memdesc:ac32b595dbcad270a15ed20df549c946f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union this tree's set of active values with the active values of the other tree, whose <code>ValueType</code> may be different.  <a href="#ac32b595dbcad270a15ed20df549c946f">More...</a><br /></td></tr>
<tr class="separator:ac32b595dbcad270a15ed20df549c946f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4089e30211443f0d6431cff8bef3cc"><td class="memTemplParams" colspan="2">template&lt;typename OtherRootNodeType &gt; </td></tr>
<tr class="memitem:a4a4089e30211443f0d6431cff8bef3cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a4a4089e30211443f0d6431cff8bef3cc">topologyIntersection</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; OtherRootNodeType &gt; &amp;other)</td></tr>
<tr class="memdesc:a4a4089e30211443f0d6431cff8bef3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects this tree's set of active values with the active values of the other tree, whose <code>ValueType</code> may be different.  <a href="#a4a4089e30211443f0d6431cff8bef3cc">More...</a><br /></td></tr>
<tr class="separator:a4a4089e30211443f0d6431cff8bef3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6ad1abf61c3b13d7ad7408f4634226"><td class="memTemplParams" colspan="2">template&lt;typename OtherRootNodeType &gt; </td></tr>
<tr class="memitem:a7c6ad1abf61c3b13d7ad7408f4634226"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a7c6ad1abf61c3b13d7ad7408f4634226">topologyDifference</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; OtherRootNodeType &gt; &amp;other)</td></tr>
<tr class="memdesc:a7c6ad1abf61c3b13d7ad7408f4634226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference this tree's set of active values with the active values of the other tree, whose <code>ValueType</code> may be different. So a resulting voxel will be active only if the original voxel is active in this tree and inactive in the other tree.  <a href="#a7c6ad1abf61c3b13d7ad7408f4634226">More...</a><br /></td></tr>
<tr class="separator:a7c6ad1abf61c3b13d7ad7408f4634226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ca864d49b3df73bd482307bd800577"><td class="memTemplParams" colspan="2">template&lt;typename CombineOp &gt; </td></tr>
<tr class="memitem:a11ca864d49b3df73bd482307bd800577"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a11ca864d49b3df73bd482307bd800577">combine</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> &amp;other, CombineOp &amp;op, bool <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a462c7056adc55d8da2cc5828934ff859">prune</a>=false)</td></tr>
<tr class="separator:a11ca864d49b3df73bd482307bd800577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d84c2c10bb99b93dd6be52bf153b43b"><td class="memTemplParams" colspan="2">template&lt;typename CombineOp &gt; </td></tr>
<tr class="memitem:a3d84c2c10bb99b93dd6be52bf153b43b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a3d84c2c10bb99b93dd6be52bf153b43b">combine</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> &amp;other, const CombineOp &amp;op, bool <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a462c7056adc55d8da2cc5828934ff859">prune</a>=false)</td></tr>
<tr class="separator:a3d84c2c10bb99b93dd6be52bf153b43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71140d5e67f0fce2c7fe0ae119db9711"><td class="memTemplParams" colspan="2">template&lt;typename ExtendedCombineOp &gt; </td></tr>
<tr class="memitem:a71140d5e67f0fce2c7fe0ae119db9711"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a71140d5e67f0fce2c7fe0ae119db9711">combineExtended</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> &amp;other, ExtendedCombineOp &amp;op, bool <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a462c7056adc55d8da2cc5828934ff859">prune</a>=false)</td></tr>
<tr class="separator:a71140d5e67f0fce2c7fe0ae119db9711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1557fead163be5539d36caffdbf0fb2"><td class="memTemplParams" colspan="2">template&lt;typename ExtendedCombineOp &gt; </td></tr>
<tr class="memitem:aa1557fead163be5539d36caffdbf0fb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#aa1557fead163be5539d36caffdbf0fb2">combineExtended</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> &amp;other, const ExtendedCombineOp &amp;op, bool <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a462c7056adc55d8da2cc5828934ff859">prune</a>=false)</td></tr>
<tr class="separator:aa1557fead163be5539d36caffdbf0fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cbd79b5ac7b0898386849c5d93e4cc"><td class="memTemplParams" colspan="2">template&lt;typename CombineOp , typename OtherTreeType &gt; </td></tr>
<tr class="memitem:af1cbd79b5ac7b0898386849c5d93e4cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#af1cbd79b5ac7b0898386849c5d93e4cc">combine2</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> &amp;a, const OtherTreeType &amp;b, CombineOp &amp;op, bool <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a462c7056adc55d8da2cc5828934ff859">prune</a>=false)</td></tr>
<tr class="separator:af1cbd79b5ac7b0898386849c5d93e4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5795706d9693640529f8a55ac1001fc"><td class="memTemplParams" colspan="2">template&lt;typename CombineOp , typename OtherTreeType &gt; </td></tr>
<tr class="memitem:aa5795706d9693640529f8a55ac1001fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#aa5795706d9693640529f8a55ac1001fc">combine2</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> &amp;a, const OtherTreeType &amp;b, const CombineOp &amp;op, bool <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a462c7056adc55d8da2cc5828934ff859">prune</a>=false)</td></tr>
<tr class="separator:aa5795706d9693640529f8a55ac1001fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878302f18a7f23adac7da7a9fc5f7441"><td class="memTemplParams" colspan="2">template&lt;typename ExtendedCombineOp , typename OtherTreeType &gt; </td></tr>
<tr class="memitem:a878302f18a7f23adac7da7a9fc5f7441"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a878302f18a7f23adac7da7a9fc5f7441">combine2Extended</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> &amp;a, const OtherTreeType &amp;b, ExtendedCombineOp &amp;op, bool <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a462c7056adc55d8da2cc5828934ff859">prune</a>=false)</td></tr>
<tr class="separator:a878302f18a7f23adac7da7a9fc5f7441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606623b3e96a1a62594583f54fdb30e0"><td class="memTemplParams" colspan="2">template&lt;typename ExtendedCombineOp , typename OtherTreeType &gt; </td></tr>
<tr class="memitem:a606623b3e96a1a62594583f54fdb30e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a606623b3e96a1a62594583f54fdb30e0">combine2Extended</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> &amp;a, const OtherTreeType &amp;b, const ExtendedCombineOp &amp;, bool <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a462c7056adc55d8da2cc5828934ff859">prune</a>=false)</td></tr>
<tr class="separator:a606623b3e96a1a62594583f54fdb30e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a215bc79db1dd008c0eaa51e1831a34"><td class="memTemplParams" colspan="2">template&lt;typename BBoxOp &gt; </td></tr>
<tr class="memitem:a7a215bc79db1dd008c0eaa51e1831a34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a7a215bc79db1dd008c0eaa51e1831a34">visitActiveBBox</a> (BBoxOp &amp;op) const</td></tr>
<tr class="memdesc:a7a215bc79db1dd008c0eaa51e1831a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use sparse traversal to call the given functor with bounding box information for all active tiles and leaf nodes or active voxels in the tree.  <a href="#a7a215bc79db1dd008c0eaa51e1831a34">More...</a><br /></td></tr>
<tr class="separator:a7a215bc79db1dd008c0eaa51e1831a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fa8714e1d4021da4f150b5e24385a0"><td class="memTemplParams" colspan="2">template&lt;typename VisitorOp &gt; </td></tr>
<tr class="memitem:a92fa8714e1d4021da4f150b5e24385a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a92fa8714e1d4021da4f150b5e24385a0">visit</a> (VisitorOp &amp;op)</td></tr>
<tr class="separator:a92fa8714e1d4021da4f150b5e24385a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5edcc00e9c808a70cf54f70d1c6cf1c"><td class="memTemplParams" colspan="2">template&lt;typename VisitorOp &gt; </td></tr>
<tr class="memitem:ab5edcc00e9c808a70cf54f70d1c6cf1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ab5edcc00e9c808a70cf54f70d1c6cf1c">visit</a> (const VisitorOp &amp;op)</td></tr>
<tr class="separator:ab5edcc00e9c808a70cf54f70d1c6cf1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca906e71df15cfed732dc0fd44f01c37"><td class="memTemplParams" colspan="2">template&lt;typename VisitorOp &gt; </td></tr>
<tr class="memitem:aca906e71df15cfed732dc0fd44f01c37"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#aca906e71df15cfed732dc0fd44f01c37">visit</a> (VisitorOp &amp;op) const</td></tr>
<tr class="separator:aca906e71df15cfed732dc0fd44f01c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1043a1492b198e8f675b9fd8fafce4d"><td class="memTemplParams" colspan="2">template&lt;typename VisitorOp &gt; </td></tr>
<tr class="memitem:ac1043a1492b198e8f675b9fd8fafce4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ac1043a1492b198e8f675b9fd8fafce4d">visit</a> (const VisitorOp &amp;op) const</td></tr>
<tr class="separator:ac1043a1492b198e8f675b9fd8fafce4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a669237d39f3536882fd6c16fb32fde"><td class="memTemplParams" colspan="2">template&lt;typename OtherTreeType , typename VisitorOp &gt; </td></tr>
<tr class="memitem:a3a669237d39f3536882fd6c16fb32fde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a3a669237d39f3536882fd6c16fb32fde">visit2</a> (OtherTreeType &amp;other, VisitorOp &amp;op)</td></tr>
<tr class="separator:a3a669237d39f3536882fd6c16fb32fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada17792f9a96a8fd4f9dd881840a036b"><td class="memTemplParams" colspan="2">template&lt;typename OtherTreeType , typename VisitorOp &gt; </td></tr>
<tr class="memitem:ada17792f9a96a8fd4f9dd881840a036b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ada17792f9a96a8fd4f9dd881840a036b">visit2</a> (OtherTreeType &amp;other, const VisitorOp &amp;op)</td></tr>
<tr class="separator:ada17792f9a96a8fd4f9dd881840a036b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62bdd502fe79d887371737fe1109c62"><td class="memTemplParams" colspan="2">template&lt;typename OtherTreeType , typename VisitorOp &gt; </td></tr>
<tr class="memitem:ab62bdd502fe79d887371737fe1109c62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ab62bdd502fe79d887371737fe1109c62">visit2</a> (OtherTreeType &amp;other, VisitorOp &amp;op) const</td></tr>
<tr class="separator:ab62bdd502fe79d887371737fe1109c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348192f35f7eb83f81b76089880a515a"><td class="memTemplParams" colspan="2">template&lt;typename OtherTreeType , typename VisitorOp &gt; </td></tr>
<tr class="memitem:a348192f35f7eb83f81b76089880a515a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a348192f35f7eb83f81b76089880a515a">visit2</a> (OtherTreeType &amp;other, const VisitorOp &amp;op) const</td></tr>
<tr class="separator:a348192f35f7eb83f81b76089880a515a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2362da85404e6072c0e3f39006f4bbd0"><td class="memTemplParams" colspan="2">template&lt;typename IterT &gt; </td></tr>
<tr class="memitem:a2362da85404e6072c0e3f39006f4bbd0"><td class="memTemplItemLeft" align="right" valign="top">IterT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2362da85404e6072c0e3f39006f4bbd0">begin</a> ()</td></tr>
<tr class="memdesc:a2362da85404e6072c0e3f39006f4bbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator of type <code>IterT</code> (for example, <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2362da85404e6072c0e3f39006f4bbd0" title="Return an iterator of type IterT (for example, begin&lt;ValueOnIter&gt;() is equivalent to beginValueOn())...">begin&lt;ValueOnIter&gt;()</a> is equivalent to <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a7b8568cb11eacfedf042fa1eda680a45" title="Return an iterator over active values (tile and voxel) across all nodes. ">beginValueOn()</a>).  <a href="#a2362da85404e6072c0e3f39006f4bbd0">More...</a><br /></td></tr>
<tr class="separator:a2362da85404e6072c0e3f39006f4bbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b20983e631a389ca3fac03927a65d9f"><td class="memTemplParams" colspan="2">template&lt;typename CIterT &gt; </td></tr>
<tr class="memitem:a0b20983e631a389ca3fac03927a65d9f"><td class="memTemplItemLeft" align="right" valign="top">CIterT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a0b20983e631a389ca3fac03927a65d9f">cbegin</a> () const</td></tr>
<tr class="memdesc:a0b20983e631a389ca3fac03927a65d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator of type CIterT (for example, <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a0b20983e631a389ca3fac03927a65d9f" title="Return a const iterator of type CIterT (for example, cbegin&lt;ValueOnCIter&gt;() is equivalent to cbeginVa...">cbegin&lt;ValueOnCIter&gt;()</a> is equivalent to <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9141b760807bdde0cad1e9bee1cc137a" title="Return an iterator over active values (tile and voxel) across all nodes. ">cbeginValueOn()</a>).  <a href="#a0b20983e631a389ca3fac03927a65d9f">More...</a><br /></td></tr>
<tr class="separator:a0b20983e631a389ca3fac03927a65d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fdbd92824d1705fe81fa937376fcd1"><td class="memTemplParams" colspan="2">template&lt;typename IterT &gt; </td></tr>
<tr class="memitem:ad2fdbd92824d1705fe81fa937376fcd1"><td class="memTemplItemLeft" align="right" valign="top">IterT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad2fdbd92824d1705fe81fa937376fcd1">cbegin</a> () const</td></tr>
<tr class="separator:ad2fdbd92824d1705fe81fa937376fcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ed3f7da1f8419a8af8171677116a2b"><td class="memTemplParams" colspan="2">template&lt;typename AccessT &gt; </td></tr>
<tr class="memitem:a54ed3f7da1f8419a8af8171677116a2b"><td class="memTemplItemLeft" align="right" valign="top">const RootNodeType::ValueType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a54ed3f7da1f8419a8af8171677116a2b">getValue</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz, AccessT &amp;accessor) const</td></tr>
<tr class="separator:a54ed3f7da1f8419a8af8171677116a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1969dd5ae7c1715c8abcfcd82aeeff85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2bfd3918f8d5734228a8a97392a91176">RootNodeType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a1969dd5ae7c1715c8abcfcd82aeeff85">root</a> ()</td></tr>
<tr class="memdesc:a1969dd5ae7c1715c8abcfcd82aeeff85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this tree's root node.  <a href="#a1969dd5ae7c1715c8abcfcd82aeeff85">More...</a><br /></td></tr>
<tr class="separator:a1969dd5ae7c1715c8abcfcd82aeeff85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2f3617212eb5a8e9fcb276f812b995"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2bfd3918f8d5734228a8a97392a91176">RootNodeType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#aef2f3617212eb5a8e9fcb276f812b995">root</a> () const</td></tr>
<tr class="memdesc:aef2f3617212eb5a8e9fcb276f812b995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this tree's root node.  <a href="#aef2f3617212eb5a8e9fcb276f812b995">More...</a><br /></td></tr>
<tr class="separator:aef2f3617212eb5a8e9fcb276f812b995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad87de532e553a73bd6e3b55337eff1d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad87de532e553a73bd6e3b55337eff1d5">sparseFill</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox, const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;value, bool active=true)</td></tr>
<tr class="memdesc:ad87de532e553a73bd6e3b55337eff1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all voxels within a given axis-aligned box to a constant value.  <a href="#ad87de532e553a73bd6e3b55337eff1d5">More...</a><br /></td></tr>
<tr class="separator:ad87de532e553a73bd6e3b55337eff1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bd60c87fb75e3bb7a9b5099f3a4bdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a69bd60c87fb75e3bb7a9b5099f3a4bdf">fill</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox, const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;value, bool active=true)</td></tr>
<tr class="memdesc:a69bd60c87fb75e3bb7a9b5099f3a4bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all voxels within a given axis-aligned box to a constant value.  <a href="#a69bd60c87fb75e3bb7a9b5099f3a4bdf">More...</a><br /></td></tr>
<tr class="separator:a69bd60c87fb75e3bb7a9b5099f3a4bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1096806c2a3867c6a168981093c5a0fe"><td class="memTemplParams" colspan="2">template&lt;typename NodeType &gt; </td></tr>
<tr class="memitem:a1096806c2a3867c6a168981093c5a0fe"><td class="memTemplItemLeft" align="right" valign="top">NodeType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a1096806c2a3867c6a168981093c5a0fe">probeNode</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz)</td></tr>
<tr class="memdesc:a1096806c2a3867c6a168981093c5a0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the node of type <code>NodeType</code> that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>.  <a href="#a1096806c2a3867c6a168981093c5a0fe">More...</a><br /></td></tr>
<tr class="separator:a1096806c2a3867c6a168981093c5a0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b9323b7d38a7ef15a890cf582e5b79"><td class="memTemplParams" colspan="2">template&lt;typename NodeType &gt; </td></tr>
<tr class="memitem:ae1b9323b7d38a7ef15a890cf582e5b79"><td class="memTemplItemLeft" align="right" valign="top">const NodeType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ae1b9323b7d38a7ef15a890cf582e5b79">probeConstNode</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memdesc:ae1b9323b7d38a7ef15a890cf582e5b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the node of type <code>NodeType</code> that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>.  <a href="#ae1b9323b7d38a7ef15a890cf582e5b79">More...</a><br /></td></tr>
<tr class="separator:ae1b9323b7d38a7ef15a890cf582e5b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e35932262eb2206e2b87797105d2b3"><td class="memTemplParams" colspan="2">template&lt;typename NodeType &gt; </td></tr>
<tr class="memitem:a10e35932262eb2206e2b87797105d2b3"><td class="memTemplItemLeft" align="right" valign="top">const NodeType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a10e35932262eb2206e2b87797105d2b3">probeNode</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memdesc:a10e35932262eb2206e2b87797105d2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the node of type <code>NodeType</code> that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>.  <a href="#a10e35932262eb2206e2b87797105d2b3">More...</a><br /></td></tr>
<tr class="separator:a10e35932262eb2206e2b87797105d2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a48bab17c2781af76eacbc64ba399e1d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad69afaa4f94a67ce2f7d0b18b339291e">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a48bab17c2781af76eacbc64ba399e1d7">probeLeaf</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz)</td></tr>
<tr class="memdesc:a48bab17c2781af76eacbc64ba399e1d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>.  <a href="#a48bab17c2781af76eacbc64ba399e1d7">More...</a><br /></td></tr>
<tr class="separator:a48bab17c2781af76eacbc64ba399e1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21747eeca7dea89fcf3aa2cad2bf76f2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad69afaa4f94a67ce2f7d0b18b339291e">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a21747eeca7dea89fcf3aa2cad2bf76f2">probeConstLeaf</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memdesc:a21747eeca7dea89fcf3aa2cad2bf76f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>.  <a href="#a21747eeca7dea89fcf3aa2cad2bf76f2">More...</a><br /></td></tr>
<tr class="separator:a21747eeca7dea89fcf3aa2cad2bf76f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21a2d47ff0aecdaf336389ad95c466d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad69afaa4f94a67ce2f7d0b18b339291e">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ac21a2d47ff0aecdaf336389ad95c466d">probeLeaf</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memdesc:ac21a2d47ff0aecdaf336389ad95c466d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>.  <a href="#ac21a2d47ff0aecdaf336389ad95c466d">More...</a><br /></td></tr>
<tr class="separator:ac21a2d47ff0aecdaf336389ad95c466d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a33a3cd99c0b9c78e1f6da3d9a36fdaff"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a33a3cd99c0b9c78e1f6da3d9a36fdaff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a33a3cd99c0b9c78e1f6da3d9a36fdaff">getNodes</a> (ArrayT &amp;array)</td></tr>
<tr class="memdesc:a33a3cd99c0b9c78e1f6da3d9a36fdaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all nodes of a certain type to a container with the following API:  <a href="#a33a3cd99c0b9c78e1f6da3d9a36fdaff">More...</a><br /></td></tr>
<tr class="separator:a33a3cd99c0b9c78e1f6da3d9a36fdaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a64f33ad83ba0854b8502a061eb30b"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:ab6a64f33ad83ba0854b8502a061eb30b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ab6a64f33ad83ba0854b8502a061eb30b">getNodes</a> (ArrayT &amp;array) const</td></tr>
<tr class="memdesc:ab6a64f33ad83ba0854b8502a061eb30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all nodes of a certain type to a container with the following API:  <a href="#ab6a64f33ad83ba0854b8502a061eb30b">More...</a><br /></td></tr>
<tr class="separator:ab6a64f33ad83ba0854b8502a061eb30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a57d942eee09cc10fe76f0aae793a5d38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a57d942eee09cc10fe76f0aae793a5d38">attachAccessor</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, true &gt; &amp;) const</td></tr>
<tr class="memdesc:a57d942eee09cc10fe76f0aae793a5d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an accessor for this tree. Registered accessors are automatically cleared whenever one of this tree's nodes is deleted.  <a href="#a57d942eee09cc10fe76f0aae793a5d38">More...</a><br /></td></tr>
<tr class="separator:a57d942eee09cc10fe76f0aae793a5d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fd2afc5be6933cfb96d0902032faad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad5fd2afc5be6933cfb96d0902032faad">attachAccessor</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, true &gt; &amp;) const</td></tr>
<tr class="memdesc:ad5fd2afc5be6933cfb96d0902032faad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an accessor for this tree. Registered accessors are automatically cleared whenever one of this tree's nodes is deleted.  <a href="#ad5fd2afc5be6933cfb96d0902032faad">More...</a><br /></td></tr>
<tr class="separator:ad5fd2afc5be6933cfb96d0902032faad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9580b2e23432188a36bbe8070e2f8255"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9580b2e23432188a36bbe8070e2f8255">attachAccessor</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, false &gt; &amp;) const</td></tr>
<tr class="memdesc:a9580b2e23432188a36bbe8070e2f8255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy implementations.  <a href="#a9580b2e23432188a36bbe8070e2f8255">More...</a><br /></td></tr>
<tr class="separator:a9580b2e23432188a36bbe8070e2f8255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa220edf8ed02b09c53b6f353048668df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#aa220edf8ed02b09c53b6f353048668df">attachAccessor</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, false &gt; &amp;) const</td></tr>
<tr class="memdesc:aa220edf8ed02b09c53b6f353048668df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy implementations.  <a href="#aa220edf8ed02b09c53b6f353048668df">More...</a><br /></td></tr>
<tr class="separator:aa220edf8ed02b09c53b6f353048668df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4a7a9efd8a2eb16533f0c77f28ae162b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a4a7a9efd8a2eb16533f0c77f28ae162b">releaseAccessor</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, true &gt; &amp;) const</td></tr>
<tr class="memdesc:a4a7a9efd8a2eb16533f0c77f28ae162b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an accessor so that it is no longer automatically cleared.  <a href="#a4a7a9efd8a2eb16533f0c77f28ae162b">More...</a><br /></td></tr>
<tr class="separator:a4a7a9efd8a2eb16533f0c77f28ae162b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793d13ab6b6648f44762370a36807b9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a793d13ab6b6648f44762370a36807b9e">releaseAccessor</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, true &gt; &amp;) const</td></tr>
<tr class="memdesc:a793d13ab6b6648f44762370a36807b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an accessor so that it is no longer automatically cleared.  <a href="#a793d13ab6b6648f44762370a36807b9e">More...</a><br /></td></tr>
<tr class="separator:a793d13ab6b6648f44762370a36807b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0ff7b9c537368ef9f40548ea68675a4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a0ff7b9c537368ef9f40548ea68675a4a">releaseAccessor</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, false &gt; &amp;) const</td></tr>
<tr class="memdesc:a0ff7b9c537368ef9f40548ea68675a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy implementations.  <a href="#a0ff7b9c537368ef9f40548ea68675a4a">More...</a><br /></td></tr>
<tr class="separator:a0ff7b9c537368ef9f40548ea68675a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1330f899e7de32d5f3ed6e48332c4fce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a1330f899e7de32d5f3ed6e48332c4fce">releaseAccessor</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, false &gt; &amp;) const</td></tr>
<tr class="memdesc:a1330f899e7de32d5f3ed6e48332c4fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy implementations.  <a href="#a1330f899e7de32d5f3ed6e48332c4fce">More...</a><br /></td></tr>
<tr class="separator:a1330f899e7de32d5f3ed6e48332c4fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3ab90a45b79a0e945673e1900fe73169"><td class="memItemLeft" align="right" valign="top">RootNodeType::ChildOnCIter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a3ab90a45b79a0e945673e1900fe73169">beginRootChildren</a> () const</td></tr>
<tr class="memdesc:a3ab90a45b79a0e945673e1900fe73169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over children of the root node.  <a href="#a3ab90a45b79a0e945673e1900fe73169">More...</a><br /></td></tr>
<tr class="separator:a3ab90a45b79a0e945673e1900fe73169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb01b6c018df148eca289111966d0ec2"><td class="memItemLeft" align="right" valign="top">RootNodeType::ChildOnCIter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#acb01b6c018df148eca289111966d0ec2">cbeginRootChildren</a> () const</td></tr>
<tr class="memdesc:acb01b6c018df148eca289111966d0ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over children of the root node.  <a href="#acb01b6c018df148eca289111966d0ec2">More...</a><br /></td></tr>
<tr class="separator:acb01b6c018df148eca289111966d0ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c83c14d8f83d5253045dd94d4951d25"><td class="memItemLeft" align="right" valign="top">RootNodeType::ChildOnIter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a4c83c14d8f83d5253045dd94d4951d25">beginRootChildren</a> ()</td></tr>
<tr class="memdesc:a4c83c14d8f83d5253045dd94d4951d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over children of the root node.  <a href="#a4c83c14d8f83d5253045dd94d4951d25">More...</a><br /></td></tr>
<tr class="separator:a4c83c14d8f83d5253045dd94d4951d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6cf986cc542083d6a076528addbcb875"><td class="memItemLeft" align="right" valign="top">RootNodeType::ChildOffCIter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a6cf986cc542083d6a076528addbcb875">beginRootTiles</a> () const</td></tr>
<tr class="memdesc:a6cf986cc542083d6a076528addbcb875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over non-child entries of the root node's table.  <a href="#a6cf986cc542083d6a076528addbcb875">More...</a><br /></td></tr>
<tr class="separator:a6cf986cc542083d6a076528addbcb875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b8ffcccb89566bb65268c67451103d"><td class="memItemLeft" align="right" valign="top">RootNodeType::ChildOffCIter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a17b8ffcccb89566bb65268c67451103d">cbeginRootTiles</a> () const</td></tr>
<tr class="memdesc:a17b8ffcccb89566bb65268c67451103d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over non-child entries of the root node's table.  <a href="#a17b8ffcccb89566bb65268c67451103d">More...</a><br /></td></tr>
<tr class="separator:a17b8ffcccb89566bb65268c67451103d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339dea8047a951d8ae190efb80a269cd"><td class="memItemLeft" align="right" valign="top">RootNodeType::ChildOffIter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a339dea8047a951d8ae190efb80a269cd">beginRootTiles</a> ()</td></tr>
<tr class="memdesc:a339dea8047a951d8ae190efb80a269cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over non-child entries of the root node's table.  <a href="#a339dea8047a951d8ae190efb80a269cd">More...</a><br /></td></tr>
<tr class="separator:a339dea8047a951d8ae190efb80a269cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a01cde33f56bee8158f4ef1ed1b740e14"><td class="memItemLeft" align="right" valign="top">RootNodeType::ChildAllCIter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a01cde33f56bee8158f4ef1ed1b740e14">beginRootDense</a> () const</td></tr>
<tr class="memdesc:a01cde33f56bee8158f4ef1ed1b740e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over all entries of the root node's table.  <a href="#a01cde33f56bee8158f4ef1ed1b740e14">More...</a><br /></td></tr>
<tr class="separator:a01cde33f56bee8158f4ef1ed1b740e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab243ff971d166bec5725c13f8ba82549"><td class="memItemLeft" align="right" valign="top">RootNodeType::ChildAllCIter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ab243ff971d166bec5725c13f8ba82549">cbeginRootDense</a> () const</td></tr>
<tr class="memdesc:ab243ff971d166bec5725c13f8ba82549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over all entries of the root node's table.  <a href="#ab243ff971d166bec5725c13f8ba82549">More...</a><br /></td></tr>
<tr class="separator:ab243ff971d166bec5725c13f8ba82549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6659f4ecac5a96ff225ade7f4f4186"><td class="memItemLeft" align="right" valign="top">RootNodeType::ChildAllIter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2d6659f4ecac5a96ff225ade7f4f4186">beginRootDense</a> ()</td></tr>
<tr class="memdesc:a2d6659f4ecac5a96ff225ade7f4f4186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over all entries of the root node's table.  <a href="#a2d6659f4ecac5a96ff225ade7f4f4186">More...</a><br /></td></tr>
<tr class="separator:a2d6659f4ecac5a96ff225ade7f4f4186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af6a7c7dea5e04a9572a5ca396269f303"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a5863d8ed73c4bb7a064b678843cfce2d">NodeIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#af6a7c7dea5e04a9572a5ca396269f303">beginNode</a> ()</td></tr>
<tr class="memdesc:af6a7c7dea5e04a9572a5ca396269f303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over all nodes in this tree.  <a href="#af6a7c7dea5e04a9572a5ca396269f303">More...</a><br /></td></tr>
<tr class="separator:af6a7c7dea5e04a9572a5ca396269f303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa601823463a58368ae05ba5b38e51eb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#acf558d7273da3c5badff79938c9b43e2">NodeCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#aa601823463a58368ae05ba5b38e51eb2">beginNode</a> () const</td></tr>
<tr class="memdesc:aa601823463a58368ae05ba5b38e51eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over all nodes in this tree.  <a href="#aa601823463a58368ae05ba5b38e51eb2">More...</a><br /></td></tr>
<tr class="separator:aa601823463a58368ae05ba5b38e51eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0073c628dee780e70feb8cc7ca1790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#acf558d7273da3c5badff79938c9b43e2">NodeCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#acd0073c628dee780e70feb8cc7ca1790">cbeginNode</a> () const</td></tr>
<tr class="memdesc:acd0073c628dee780e70feb8cc7ca1790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over all nodes in this tree.  <a href="#acd0073c628dee780e70feb8cc7ca1790">More...</a><br /></td></tr>
<tr class="separator:acd0073c628dee780e70feb8cc7ca1790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad71e0011e4f27f225c923b8e0b404dca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#aa71c9eea9da1f0718ecd069e34823f3f">LeafIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad71e0011e4f27f225c923b8e0b404dca">beginLeaf</a> ()</td></tr>
<tr class="memdesc:ad71e0011e4f27f225c923b8e0b404dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over all leaf nodes in this tree.  <a href="#ad71e0011e4f27f225c923b8e0b404dca">More...</a><br /></td></tr>
<tr class="separator:ad71e0011e4f27f225c923b8e0b404dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190097f122b16e558ace298e0baf81a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a30cc6e43580444de39db347e1c0a9dee">LeafCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a190097f122b16e558ace298e0baf81a9">beginLeaf</a> () const</td></tr>
<tr class="memdesc:a190097f122b16e558ace298e0baf81a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over all leaf nodes in this tree.  <a href="#a190097f122b16e558ace298e0baf81a9">More...</a><br /></td></tr>
<tr class="separator:a190097f122b16e558ace298e0baf81a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee8c8b0ef6478872e7a47bb62bd388f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a30cc6e43580444de39db347e1c0a9dee">LeafCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2ee8c8b0ef6478872e7a47bb62bd388f">cbeginLeaf</a> () const</td></tr>
<tr class="memdesc:a2ee8c8b0ef6478872e7a47bb62bd388f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over all leaf nodes in this tree.  <a href="#a2ee8c8b0ef6478872e7a47bb62bd388f">More...</a><br /></td></tr>
<tr class="separator:a2ee8c8b0ef6478872e7a47bb62bd388f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afdf6fa279da1f6839a3ca381828220df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a6ccc5d0e86ce5b20fe01cb1ab2c897fe">ValueAllIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#afdf6fa279da1f6839a3ca381828220df">beginValueAll</a> ()</td></tr>
<tr class="memdesc:afdf6fa279da1f6839a3ca381828220df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over all values (tile and voxel) across all nodes.  <a href="#afdf6fa279da1f6839a3ca381828220df">More...</a><br /></td></tr>
<tr class="separator:afdf6fa279da1f6839a3ca381828220df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3638d1f86ab66eb1087910b4172a81e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2bb945a8d6efebff61e309908fb87bc0">ValueAllCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#af3638d1f86ab66eb1087910b4172a81e">beginValueAll</a> () const</td></tr>
<tr class="memdesc:af3638d1f86ab66eb1087910b4172a81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over all values (tile and voxel) across all nodes.  <a href="#af3638d1f86ab66eb1087910b4172a81e">More...</a><br /></td></tr>
<tr class="separator:af3638d1f86ab66eb1087910b4172a81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ab5e975ed9515b08cb3ce3cb5dc722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2bb945a8d6efebff61e309908fb87bc0">ValueAllCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a45ab5e975ed9515b08cb3ce3cb5dc722">cbeginValueAll</a> () const</td></tr>
<tr class="memdesc:a45ab5e975ed9515b08cb3ce3cb5dc722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over all values (tile and voxel) across all nodes.  <a href="#a45ab5e975ed9515b08cb3ce3cb5dc722">More...</a><br /></td></tr>
<tr class="separator:a45ab5e975ed9515b08cb3ce3cb5dc722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7b8568cb11eacfedf042fa1eda680a45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#afe548862b5e057f0cea00b94e00809bf">ValueOnIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a7b8568cb11eacfedf042fa1eda680a45">beginValueOn</a> ()</td></tr>
<tr class="memdesc:a7b8568cb11eacfedf042fa1eda680a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over active values (tile and voxel) across all nodes.  <a href="#a7b8568cb11eacfedf042fa1eda680a45">More...</a><br /></td></tr>
<tr class="separator:a7b8568cb11eacfedf042fa1eda680a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecac88b99d3c8064036ec4747260dfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a7afd976ee17f253e8f5b449115507c78">ValueOnCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a4ecac88b99d3c8064036ec4747260dfa">beginValueOn</a> () const</td></tr>
<tr class="memdesc:a4ecac88b99d3c8064036ec4747260dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over active values (tile and voxel) across all nodes.  <a href="#a4ecac88b99d3c8064036ec4747260dfa">More...</a><br /></td></tr>
<tr class="separator:a4ecac88b99d3c8064036ec4747260dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9141b760807bdde0cad1e9bee1cc137a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a7afd976ee17f253e8f5b449115507c78">ValueOnCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9141b760807bdde0cad1e9bee1cc137a">cbeginValueOn</a> () const</td></tr>
<tr class="memdesc:a9141b760807bdde0cad1e9bee1cc137a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over active values (tile and voxel) across all nodes.  <a href="#a9141b760807bdde0cad1e9bee1cc137a">More...</a><br /></td></tr>
<tr class="separator:a9141b760807bdde0cad1e9bee1cc137a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad555f92c70739496805fb480c3b38f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a15dad3a20f9ca8647f21cb8394fc1847">ValueOffIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad555f92c70739496805fb480c3b38f85">beginValueOff</a> ()</td></tr>
<tr class="memdesc:ad555f92c70739496805fb480c3b38f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over inactive values (tile and voxel) across all nodes.  <a href="#ad555f92c70739496805fb480c3b38f85">More...</a><br /></td></tr>
<tr class="separator:ad555f92c70739496805fb480c3b38f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2ad19bf53695a6a7c3ab316a67b40c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a183496e56dd4a8c98c7b85e2b2d58677">ValueOffCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a6b2ad19bf53695a6a7c3ab316a67b40c">beginValueOff</a> () const</td></tr>
<tr class="memdesc:a6b2ad19bf53695a6a7c3ab316a67b40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over inactive values (tile and voxel) across all nodes.  <a href="#a6b2ad19bf53695a6a7c3ab316a67b40c">More...</a><br /></td></tr>
<tr class="separator:a6b2ad19bf53695a6a7c3ab316a67b40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de8db6621c42bbe606d4b6739e4462f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a183496e56dd4a8c98c7b85e2b2d58677">ValueOffCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a1de8db6621c42bbe606d4b6739e4462f">cbeginValueOff</a> () const</td></tr>
<tr class="memdesc:a1de8db6621c42bbe606d4b6739e4462f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator over inactive values (tile and voxel) across all nodes.  <a href="#a1de8db6621c42bbe606d4b6739e4462f">More...</a><br /></td></tr>
<tr class="separator:a1de8db6621c42bbe606d4b6739e4462f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a34b9eb7da4505530a4199fa0a55ccf20"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceopenvdb_1_1v6__2.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a34b9eb7da4505530a4199fa0a55ccf20">treeType</a> ()</td></tr>
<tr class="memdesc:a34b9eb7da4505530a4199fa0a55ccf20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of this type of tree.  <a href="#a34b9eb7da4505530a4199fa0a55ccf20">More...</a><br /></td></tr>
<tr class="separator:a34b9eb7da4505530a4199fa0a55ccf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b91d6e713861046431c86630d23ae2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad3b91d6e713861046431c86630d23ae2">getNodeLog2Dims</a> (std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v6__2.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:ad3b91d6e713861046431c86630d23ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the type hierarchy of nodes, and return, in <em>dims</em>, a list of the Log2Dims of nodes in order from <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1RootNode.html">RootNode</a> to <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim...">LeafNode</a>.  <a href="#ad3b91d6e713861046431c86630d23ae2">More...</a><br /></td></tr>
<tr class="separator:ad3b91d6e713861046431c86630d23ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a33812eef2746f526e18a7d13ad9d0eb3"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceopenvdb_1_1v6__2.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a33812eef2746f526e18a7d13ad9d0eb3">DEPTH</a> = RootNodeType::LEVEL + 1</td></tr>
<tr class="separator:a33812eef2746f526e18a7d13ad9d0eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:afa1bfe3003db77ed8d1fa5ddac9da77d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#afa1bfe3003db77ed8d1fa5ddac9da77d">AccessorRegistry</a> = tbb::concurrent_hash_map&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, true &gt; *, bool &gt;</td></tr>
<tr class="separator:afa1bfe3003db77ed8d1fa5ddac9da77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d92c2a1286b08be885d1c1ceedfba74"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a8d92c2a1286b08be885d1c1ceedfba74">ConstAccessorRegistry</a> = tbb::concurrent_hash_map&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, true &gt; *, bool &gt;</td></tr>
<tr class="separator:a8d92c2a1286b08be885d1c1ceedfba74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7cb55df5cf1166cdd2873baa6259658f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a7cb55df5cf1166cdd2873baa6259658f">releaseAllAccessors</a> ()</td></tr>
<tr class="memdesc:a7cb55df5cf1166cdd2873baa6259658f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify all registered accessors, by calling ValueAccessor::release(), that this tree is about to be deleted.  <a href="#a7cb55df5cf1166cdd2873baa6259658f">More...</a><br /></td></tr>
<tr class="separator:a7cb55df5cf1166cdd2873baa6259658f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a45a3cfd69ab5d6507b191bfe16ad3866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2bfd3918f8d5734228a8a97392a91176">RootNodeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a45a3cfd69ab5d6507b191bfe16ad3866">mRoot</a></td></tr>
<tr class="separator:a45a3cfd69ab5d6507b191bfe16ad3866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f395a4d4c40770f12f1ac8e08fdfbda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#afa1bfe3003db77ed8d1fa5ddac9da77d">AccessorRegistry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a3f395a4d4c40770f12f1ac8e08fdfbda">mAccessorRegistry</a></td></tr>
<tr class="separator:a3f395a4d4c40770f12f1ac8e08fdfbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134837ab866ef110faba3311e77acd2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a8d92c2a1286b08be885d1c1ceedfba74">ConstAccessorRegistry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a134837ab866ef110faba3311e77acd2b">mConstAccessorRegistry</a></td></tr>
<tr class="separator:a134837ab866ef110faba3311e77acd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:acc8fe71ac3494d1f468e2fc0ece4ca34"><td class="memItemLeft" align="right" valign="top">static tbb::atomic&lt; const <a class="el" href="namespaceopenvdb_1_1v6__2.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#acc8fe71ac3494d1f468e2fc0ece4ca34">sTreeTypeName</a></td></tr>
<tr class="separator:acc8fe71ac3494d1f468e2fc0ece4ca34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afa1bfe3003db77ed8d1fa5ddac9da77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1bfe3003db77ed8d1fa5ddac9da77d">&#9670;&nbsp;</a></span>AccessorRegistry</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#afa1bfe3003db77ed8d1fa5ddac9da77d">AccessorRegistry</a> =  tbb::concurrent_hash_map&lt;<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt;<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, true&gt;*, bool&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dcdb403b52d24b40a88f9d747d1d7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcdb403b52d24b40a88f9d747d1d7ca">&#9670;&nbsp;</a></span>BuildType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a7dcdb403b52d24b40a88f9d747d1d7ca">BuildType</a> =  typename RootNodeType::BuildType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d92c2a1286b08be885d1c1ceedfba74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d92c2a1286b08be885d1c1ceedfba74">&#9670;&nbsp;</a></span>ConstAccessorRegistry</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a8d92c2a1286b08be885d1c1ceedfba74">ConstAccessorRegistry</a> =  tbb::concurrent_hash_map&lt;<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt;const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, true&gt;*, bool&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9b83fb8c1bb45cc2888847275366120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b83fb8c1bb45cc2888847275366120">&#9670;&nbsp;</a></span>ConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#ad56ea90358e26e3beef04c8f0a3339c4">ConstPtr</a> =  <a class="el" href="namespaceopenvdb_1_1v6__2.html#ad71c1f3b8d46b57fd328d48cee283c1f">SharedPtr</a>&lt;const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30cc6e43580444de39db347e1c0a9dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cc6e43580444de39db347e1c0a9dee">&#9670;&nbsp;</a></span>LeafCIter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a30cc6e43580444de39db347e1c0a9dee">LeafCIter</a> =  <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1LeafIteratorBase.html">LeafIteratorBase</a>&lt;const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ChildOnCIter&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator over all leaf nodes in this tree. </p>

</div>
</div>
<a id="aa71c9eea9da1f0718ecd069e34823f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71c9eea9da1f0718ecd069e34823f3f">&#9670;&nbsp;</a></span>LeafIter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#aa71c9eea9da1f0718ecd069e34823f3f">LeafIter</a> =  <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1LeafIteratorBase.html">LeafIteratorBase</a>&lt;<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ChildOnIter&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator over all leaf nodes in this tree. </p>

</div>
</div>
<a id="ad69afaa4f94a67ce2f7d0b18b339291e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69afaa4f94a67ce2f7d0b18b339291e">&#9670;&nbsp;</a></span>LeafNodeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad69afaa4f94a67ce2f7d0b18b339291e">LeafNodeType</a> =  typename RootNodeType::LeafNodeType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf558d7273da3c5badff79938c9b43e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf558d7273da3c5badff79938c9b43e2">&#9670;&nbsp;</a></span>NodeCIter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#acf558d7273da3c5badff79938c9b43e2">NodeCIter</a> =  <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1NodeIteratorBase.html">NodeIteratorBase</a>&lt;const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ChildOnCIter&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator over all nodes in this tree. </p>

</div>
</div>
<a id="a5863d8ed73c4bb7a064b678843cfce2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5863d8ed73c4bb7a064b678843cfce2d">&#9670;&nbsp;</a></span>NodeIter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a5863d8ed73c4bb7a064b678843cfce2d">NodeIter</a> =  <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1NodeIteratorBase.html">NodeIteratorBase</a>&lt;<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ChildOnIter&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator over all nodes in this tree. </p>

</div>
</div>
<a id="a52a147bfa3994182e5f9d5780ae55513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a147bfa3994182e5f9d5780ae55513">&#9670;&nbsp;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#ab5e4dbbad02cb8050f56d4c9a9c8c937">Ptr</a> =  <a class="el" href="namespaceopenvdb_1_1v6__2.html#ad71c1f3b8d46b57fd328d48cee283c1f">SharedPtr</a>&lt;<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bfd3918f8d5734228a8a97392a91176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfd3918f8d5734228a8a97392a91176">&#9670;&nbsp;</a></span>RootNodeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2bfd3918f8d5734228a8a97392a91176">RootNodeType</a> =  _RootNodeType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bb945a8d6efebff61e309908fb87bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb945a8d6efebff61e309908fb87bc0">&#9670;&nbsp;</a></span>ValueAllCIter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2bb945a8d6efebff61e309908fb87bc0">ValueAllCIter</a> =  <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeValueIteratorBase.html">TreeValueIteratorBase</a>&lt;const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ValueAllCIter&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ccc5d0e86ce5b20fe01cb1ab2c897fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ccc5d0e86ce5b20fe01cb1ab2c897fe">&#9670;&nbsp;</a></span>ValueAllIter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a6ccc5d0e86ce5b20fe01cb1ab2c897fe">ValueAllIter</a> =  <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeValueIteratorBase.html">TreeValueIteratorBase</a>&lt;<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ValueAllIter&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a183496e56dd4a8c98c7b85e2b2d58677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183496e56dd4a8c98c7b85e2b2d58677">&#9670;&nbsp;</a></span>ValueOffCIter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a183496e56dd4a8c98c7b85e2b2d58677">ValueOffCIter</a> =  <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeValueIteratorBase.html">TreeValueIteratorBase</a>&lt;const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ValueOffCIter&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15dad3a20f9ca8647f21cb8394fc1847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15dad3a20f9ca8647f21cb8394fc1847">&#9670;&nbsp;</a></span>ValueOffIter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a15dad3a20f9ca8647f21cb8394fc1847">ValueOffIter</a> =  <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeValueIteratorBase.html">TreeValueIteratorBase</a>&lt;<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ValueOffIter&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7afd976ee17f253e8f5b449115507c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afd976ee17f253e8f5b449115507c78">&#9670;&nbsp;</a></span>ValueOnCIter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a7afd976ee17f253e8f5b449115507c78">ValueOnCIter</a> =  <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeValueIteratorBase.html">TreeValueIteratorBase</a>&lt;const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ValueOnCIter&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe548862b5e057f0cea00b94e00809bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe548862b5e057f0cea00b94e00809bf">&#9670;&nbsp;</a></span>ValueOnIter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#afe548862b5e057f0cea00b94e00809bf">ValueOnIter</a> =  <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeValueIteratorBase.html">TreeValueIteratorBase</a>&lt;<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>, typename RootNodeType::ValueOnIter&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9575d20614e2fac00e43c5fd4fd6f32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9575d20614e2fac00e43c5fd4fd6f32b">&#9670;&nbsp;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> =  typename RootNodeType::ValueType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3dee5770ede29888f2c0136bbd7f5a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dee5770ede29888f2c0136bbd7f5a95">&#9670;&nbsp;</a></span>Tree() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a176bf2364d34c17e2e02eb44a21c520d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176bf2364d34c17e2e02eb44a21c520d">&#9670;&nbsp;</a></span>Tree() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy constructor. </p>

</div>
</div>
<a id="a213c0ce777bcd4328500431d3231a446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213c0ce777bcd4328500431d3231a446">&#9670;&nbsp;</a></span>Tree() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; OtherRootType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value conversion deep copy constructor. </p>
<p>Deep copy a tree of the same configuration as this tree type but a different ValueType, casting the other tree's values to this tree's ValueType. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v6__2_1_1TypeError.html">TypeError</a></td><td>if the other tree's configuration doesn't match this tree's or if this tree's ValueType is not constructible from the other tree's ValueType. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adae3bd6c1599f80a0f3b518945195b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae3bd6c1599f80a0f3b518945195b9e">&#9670;&nbsp;</a></span>Tree() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> </td>
          <td>(</td>
          <td class="paramtype">const OtherTreeType &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>inactiveValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>activeValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1TopologyCopy.html">TopologyCopy</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Topology copy constructor from a tree of a different type. </p>
<p>Copy the structure, i.e., the active states of tiles and voxels, of another tree of a possibly different type, but don't copy any tile or voxel values. Instead, initialize tiles and voxels with the given active and inactive values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>a tree having (possibly) a different ValueType </td></tr>
    <tr><td class="paramname">inactiveValue</td><td>background value for this tree, and the value to which all inactive tiles and voxels are initialized </td></tr>
    <tr><td class="paramname">activeValue</td><td>value to which active tiles and voxels are initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v6__2_1_1TypeError.html">TypeError</a></td><td>if the other tree's configuration doesn't match this tree's. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab198c466f09f12bcd4d14367068450c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab198c466f09f12bcd4d14367068450c6">&#9670;&nbsp;</a></span>Tree() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> </td>
          <td>(</td>
          <td class="paramtype">const OtherTreeType &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>background</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1TopologyCopy.html">TopologyCopy</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Topology copy constructor from a tree of a different type. </p>
<dl class="section note"><dt>Note</dt><dd>This topology copy constructor is generally faster than the one that takes both a foreground and a background value.</dd></dl>
<p>Copy the structure, i.e., the active states of tiles and voxels, of another tree of a possibly different type, but don't copy any tile or voxel values. Instead, initialize tiles and voxels with the given background value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>a tree having (possibly) a different ValueType </td></tr>
    <tr><td class="paramname">background</td><td>the value to which tiles and voxels are initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v6__2_1_1TypeError.html">TypeError</a></td><td>if the other tree's configuration doesn't match this tree's. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae65bce1b639b04c7f8004f54571e1453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65bce1b639b04c7f8004f54571e1453">&#9670;&nbsp;</a></span>Tree() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>background</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty tree constructor. </p>

</div>
</div>
<a id="ae0489c0d8a3abb2f8a066991ed559426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0489c0d8a3abb2f8a066991ed559426">&#9670;&nbsp;</a></span>~Tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a59650f93e1ae386d3e4d51c3ee11c447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59650f93e1ae386d3e4d51c3ee11c447">&#9670;&nbsp;</a></span>activeLeafVoxelCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v6__2.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> activeLeafVoxelCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of active voxels stored in leaf nodes. </p>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#a2e0656e740d6bd176225e3643e1b0907">TreeBase</a>.</p>

</div>
</div>
<a id="a88a3c47b3840bf275481e77ac65bb047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a3c47b3840bf275481e77ac65bb047">&#9670;&nbsp;</a></span>activeTileCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v6__2.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> activeTileCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total number of active tiles. </p>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#ad03bad9124b134c1e8ed50181d6d987d">TreeBase</a>.</p>

</div>
</div>
<a id="a6539f03b2b21ca05568d6bc8f1de9584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6539f03b2b21ca05568d6bc8f1de9584">&#9670;&nbsp;</a></span>activeVoxelCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v6__2.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> activeVoxelCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total number of active voxels. </p>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#a8786a38826997396e721f4afc8d3110d">TreeBase</a>.</p>

</div>
</div>
<a id="a6c20c22e9a994a30c9640cbe1ec982bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c20c22e9a994a30c9640cbe1ec982bc">&#9670;&nbsp;</a></span>addLeaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad69afaa4f94a67ce2f7d0b18b339291e">LeafNodeType</a> *&#160;</td>
          <td class="paramname"><em>leaf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given leaf node to this tree, creating a new branch if necessary. If a leaf node with the same origin already exists, replace it. </p>
<dl class="section warning"><dt>Warning</dt><dd>Ownership of the leaf is transferred to the tree so the client code should not attempt to delete the leaf pointer! </dd></dl>

</div>
</div>
<a id="a75454b135a1e19473aa702a90fd00802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75454b135a1e19473aa702a90fd00802">&#9670;&nbsp;</a></span>addTile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addTile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v6__2.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a tile containing voxel (x, y, z) at the specified tree level, creating a new branch if necessary. Delete any existing lower-level nodes that contain (x, y, z). </p>
<dl class="section note"><dt>Note</dt><dd><em>level</em> must be less than this tree's depth. </dd></dl>

</div>
</div>
<a id="a57d942eee09cc10fe76f0aae793a5d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d942eee09cc10fe76f0aae793a5d38">&#9670;&nbsp;</a></span>attachAccessor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void attachAccessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt;, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>accessor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register an accessor for this tree. Registered accessors are automatically cleared whenever one of this tree's nodes is deleted. </p>

</div>
</div>
<a id="ad5fd2afc5be6933cfb96d0902032faad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fd2afc5be6933cfb96d0902032faad">&#9670;&nbsp;</a></span>attachAccessor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void attachAccessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt;, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>accessor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register an accessor for this tree. Registered accessors are automatically cleared whenever one of this tree's nodes is deleted. </p>

</div>
</div>
<a id="a9580b2e23432188a36bbe8070e2f8255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9580b2e23432188a36bbe8070e2f8255">&#9670;&nbsp;</a></span>attachAccessor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void attachAccessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt;, false &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dummy implementations. </p>

</div>
</div>
<a id="aa220edf8ed02b09c53b6f353048668df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa220edf8ed02b09c53b6f353048668df">&#9670;&nbsp;</a></span>attachAccessor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void attachAccessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt;, false &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dummy implementations. </p>

</div>
</div>
<a id="a1a0b2540a4e2d53598c52a84c2974245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0b2540a4e2d53598c52a84c2974245">&#9670;&nbsp;</a></span>background()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a>&amp; background </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this tree's background value. </p>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="namespaceopenvdb_1_1v6__2_1_1tools.html#ad795f2f3910144753a5e03d12f4703de" title="Replace the background value in all the nodes of a tree. ">tools::changeBackground</a> to efficiently modify the background values. Else use tree.root().setBackground, which is serial and hence slower. </dd></dl>

</div>
</div>
<a id="a2362da85404e6072c0e3f39006f4bbd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2362da85404e6072c0e3f39006f4bbd0">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IterT begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator of type <code>IterT</code> (for example, <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2362da85404e6072c0e3f39006f4bbd0" title="Return an iterator of type IterT (for example, begin&lt;ValueOnIter&gt;() is equivalent to beginValueOn())...">begin&lt;ValueOnIter&gt;()</a> is equivalent to <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a7b8568cb11eacfedf042fa1eda680a45" title="Return an iterator over active values (tile and voxel) across all nodes. ">beginValueOn()</a>). </p>

</div>
</div>
<a id="ad71e0011e4f27f225c923b8e0b404dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71e0011e4f27f225c923b8e0b404dca">&#9670;&nbsp;</a></span>beginLeaf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#aa71c9eea9da1f0718ecd069e34823f3f">LeafIter</a> beginLeaf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over all leaf nodes in this tree. </p>

</div>
</div>
<a id="a190097f122b16e558ace298e0baf81a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190097f122b16e558ace298e0baf81a9">&#9670;&nbsp;</a></span>beginLeaf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a30cc6e43580444de39db347e1c0a9dee">LeafCIter</a> beginLeaf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over all leaf nodes in this tree. </p>

</div>
</div>
<a id="af6a7c7dea5e04a9572a5ca396269f303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a7c7dea5e04a9572a5ca396269f303">&#9670;&nbsp;</a></span>beginNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a5863d8ed73c4bb7a064b678843cfce2d">NodeIter</a> beginNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over all nodes in this tree. </p>

</div>
</div>
<a id="aa601823463a58368ae05ba5b38e51eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa601823463a58368ae05ba5b38e51eb2">&#9670;&nbsp;</a></span>beginNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#acf558d7273da3c5badff79938c9b43e2">NodeCIter</a> beginNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over all nodes in this tree. </p>

</div>
</div>
<a id="a3ab90a45b79a0e945673e1900fe73169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab90a45b79a0e945673e1900fe73169">&#9670;&nbsp;</a></span>beginRootChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RootNodeType::ChildOnCIter beginRootChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over children of the root node. </p>

</div>
</div>
<a id="a4c83c14d8f83d5253045dd94d4951d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c83c14d8f83d5253045dd94d4951d25">&#9670;&nbsp;</a></span>beginRootChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RootNodeType::ChildOnIter beginRootChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over children of the root node. </p>

</div>
</div>
<a id="a01cde33f56bee8158f4ef1ed1b740e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01cde33f56bee8158f4ef1ed1b740e14">&#9670;&nbsp;</a></span>beginRootDense() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RootNodeType::ChildAllCIter beginRootDense </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over all entries of the root node's table. </p>

</div>
</div>
<a id="a2d6659f4ecac5a96ff225ade7f4f4186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6659f4ecac5a96ff225ade7f4f4186">&#9670;&nbsp;</a></span>beginRootDense() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RootNodeType::ChildAllIter beginRootDense </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over all entries of the root node's table. </p>

</div>
</div>
<a id="a6cf986cc542083d6a076528addbcb875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf986cc542083d6a076528addbcb875">&#9670;&nbsp;</a></span>beginRootTiles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RootNodeType::ChildOffCIter beginRootTiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over non-child entries of the root node's table. </p>

</div>
</div>
<a id="a339dea8047a951d8ae190efb80a269cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339dea8047a951d8ae190efb80a269cd">&#9670;&nbsp;</a></span>beginRootTiles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RootNodeType::ChildOffIter beginRootTiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over non-child entries of the root node's table. </p>

</div>
</div>
<a id="afdf6fa279da1f6839a3ca381828220df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf6fa279da1f6839a3ca381828220df">&#9670;&nbsp;</a></span>beginValueAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a6ccc5d0e86ce5b20fe01cb1ab2c897fe">ValueAllIter</a> beginValueAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over all values (tile and voxel) across all nodes. </p>

</div>
</div>
<a id="af3638d1f86ab66eb1087910b4172a81e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3638d1f86ab66eb1087910b4172a81e">&#9670;&nbsp;</a></span>beginValueAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2bb945a8d6efebff61e309908fb87bc0">ValueAllCIter</a> beginValueAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over all values (tile and voxel) across all nodes. </p>

</div>
</div>
<a id="ad555f92c70739496805fb480c3b38f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad555f92c70739496805fb480c3b38f85">&#9670;&nbsp;</a></span>beginValueOff() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a15dad3a20f9ca8647f21cb8394fc1847">ValueOffIter</a> beginValueOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over inactive values (tile and voxel) across all nodes. </p>

</div>
</div>
<a id="a6b2ad19bf53695a6a7c3ab316a67b40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2ad19bf53695a6a7c3ab316a67b40c">&#9670;&nbsp;</a></span>beginValueOff() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a183496e56dd4a8c98c7b85e2b2d58677">ValueOffCIter</a> beginValueOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over inactive values (tile and voxel) across all nodes. </p>

</div>
</div>
<a id="a7b8568cb11eacfedf042fa1eda680a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8568cb11eacfedf042fa1eda680a45">&#9670;&nbsp;</a></span>beginValueOn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#afe548862b5e057f0cea00b94e00809bf">ValueOnIter</a> beginValueOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over active values (tile and voxel) across all nodes. </p>

</div>
</div>
<a id="a4ecac88b99d3c8064036ec4747260dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ecac88b99d3c8064036ec4747260dfa">&#9670;&nbsp;</a></span>beginValueOn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a7afd976ee17f253e8f5b449115507c78">ValueOnCIter</a> beginValueOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over active values (tile and voxel) across all nodes. </p>

</div>
</div>
<a id="a0b20983e631a389ca3fac03927a65d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b20983e631a389ca3fac03927a65d9f">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CIterT cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a const iterator of type CIterT (for example, <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a0b20983e631a389ca3fac03927a65d9f" title="Return a const iterator of type CIterT (for example, cbegin&lt;ValueOnCIter&gt;() is equivalent to cbeginVa...">cbegin&lt;ValueOnCIter&gt;()</a> is equivalent to <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9141b760807bdde0cad1e9bee1cc137a" title="Return an iterator over active values (tile and voxel) across all nodes. ">cbeginValueOn()</a>). </p>

</div>
</div>
<a id="ad2fdbd92824d1705fe81fa937376fcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fdbd92824d1705fe81fa937376fcd1">&#9670;&nbsp;</a></span>cbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IterT cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ee8c8b0ef6478872e7a47bb62bd388f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee8c8b0ef6478872e7a47bb62bd388f">&#9670;&nbsp;</a></span>cbeginLeaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a30cc6e43580444de39db347e1c0a9dee">LeafCIter</a> cbeginLeaf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over all leaf nodes in this tree. </p>

</div>
</div>
<a id="acd0073c628dee780e70feb8cc7ca1790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0073c628dee780e70feb8cc7ca1790">&#9670;&nbsp;</a></span>cbeginNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#acf558d7273da3c5badff79938c9b43e2">NodeCIter</a> cbeginNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over all nodes in this tree. </p>

</div>
</div>
<a id="acb01b6c018df148eca289111966d0ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb01b6c018df148eca289111966d0ec2">&#9670;&nbsp;</a></span>cbeginRootChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RootNodeType::ChildOnCIter cbeginRootChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over children of the root node. </p>

</div>
</div>
<a id="ab243ff971d166bec5725c13f8ba82549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab243ff971d166bec5725c13f8ba82549">&#9670;&nbsp;</a></span>cbeginRootDense()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RootNodeType::ChildAllCIter cbeginRootDense </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over all entries of the root node's table. </p>

</div>
</div>
<a id="a17b8ffcccb89566bb65268c67451103d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b8ffcccb89566bb65268c67451103d">&#9670;&nbsp;</a></span>cbeginRootTiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RootNodeType::ChildOffCIter cbeginRootTiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over non-child entries of the root node's table. </p>

</div>
</div>
<a id="a45ab5e975ed9515b08cb3ce3cb5dc722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ab5e975ed9515b08cb3ce3cb5dc722">&#9670;&nbsp;</a></span>cbeginValueAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2bb945a8d6efebff61e309908fb87bc0">ValueAllCIter</a> cbeginValueAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over all values (tile and voxel) across all nodes. </p>

</div>
</div>
<a id="a1de8db6621c42bbe606d4b6739e4462f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de8db6621c42bbe606d4b6739e4462f">&#9670;&nbsp;</a></span>cbeginValueOff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a183496e56dd4a8c98c7b85e2b2d58677">ValueOffCIter</a> cbeginValueOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over inactive values (tile and voxel) across all nodes. </p>

</div>
</div>
<a id="a9141b760807bdde0cad1e9bee1cc137a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9141b760807bdde0cad1e9bee1cc137a">&#9670;&nbsp;</a></span>cbeginValueOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a7afd976ee17f253e8f5b449115507c78">ValueOnCIter</a> cbeginValueOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator over active values (tile and voxel) across all nodes. </p>

</div>
</div>
<a id="ac8bb3912a3ce86b15842e79d0b421204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bb3912a3ce86b15842e79d0b421204">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all tiles from this tree and all nodes other than the root node. </p>

</div>
</div>
<a id="a24a9fa1c5dbac50f2d5f406f8842e368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a9fa1c5dbac50f2d5f406f8842e368">&#9670;&nbsp;</a></span>clearAllAccessors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clearAllAccessors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all registered accessors. </p>

</div>
</div>
<a id="a409633b422404c1c7df4e0ffdd02eac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409633b422404c1c7df4e0ffdd02eac1">&#9670;&nbsp;</a></span>clip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all voxels that lie outside the given axis-aligned box to the background. </p>

</div>
</div>
<a id="ae68f15390dfa328e07ae1a372deb1139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68f15390dfa328e07ae1a372deb1139">&#9670;&nbsp;</a></span>clipUnallocatedNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clipUnallocatedNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace with background tiles any nodes whose voxel buffers have not yet been allocated. </p>
<p>Typically, unallocated nodes are leaf nodes whose voxel buffers are not yet resident in memory because delayed loading is in effect. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#aaa0416e0758e74661727eb9d3c46b528" title="Read all of this tree&#39;s data buffers that are not yet resident in memory (because delayed loading is ...">readNonresidentBuffers</a>, <a class="el" href="classopenvdb_1_1v6__2_1_1io_1_1File.html#ab9e653cf43c03bbfe0decd34494892ca" title="Open the file, read the file header and the file-level metadata, and populate the grid descriptors...">io::File::open</a> </dd></dl>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#aa1c2581d705ae9b68906690051cb3898">TreeBase</a>.</p>

</div>
</div>
<a id="a11ca864d49b3df73bd482307bd800577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ca864d49b3df73bd482307bd800577">&#9670;&nbsp;</a></span>combine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CombineOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prune</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For a given function <code>f</code>, use sparse traversal to compute <code>f(this, other)</code> over all corresponding pairs of values (tile or voxel) of this tree and the other tree and store the result in this tree. This method is typically more space-efficient than the two-tree <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#af1cbd79b5ac7b0898386849c5d93e4cc">combine2()</a>, since it moves rather than copies nodes from the other tree into this tree. </p><dl class="section note"><dt>Note</dt><dd>This operation always empties the other tree. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>a tree of the same type as this tree </td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <code>void op(const T&amp; a, const T&amp; b, T&amp; result)</code>, where <code>T</code> is this tree's <code>ValueType</code>, that computes <code>result = f(a, b)</code> </td></tr>
    <tr><td class="paramname">prune</td><td>if true, prune the resulting tree one branch at a time (this is usually more space-efficient than pruning the entire tree in one pass)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd>Compute the per-voxel difference between two floating-point trees, <code>aTree</code> and <code>bTree</code>, and store the result in <code>aTree</code> (leaving <code>bTree</code> empty). <div class="fragment"><div class="line">{</div><div class="line">    <span class="keyword">struct </span>Local {</div><div class="line">        <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> diff(<span class="keyword">const</span> <span class="keywordtype">float</span>&amp; a, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; b, <span class="keywordtype">float</span>&amp; result) {</div><div class="line">            result = a - b;</div><div class="line">        }</div><div class="line">    };</div><div class="line">    aTree.combine(bTree, Local::diff);</div><div class="line">}</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example:</dt><dd>Compute <code>f * a + (1 - f) * b</code> over all voxels of two floating-point trees, <code>aTree</code> and <code>bTree</code>, and store the result in <code>aTree</code> (leaving <code>bTree</code> empty). <div class="fragment"><div class="line"><span class="keyword">namespace </span>{</div><div class="line">    <span class="keyword">struct </span>Blend {</div><div class="line">        Blend(<span class="keywordtype">float</span> f): frac(f) {}</div><div class="line">        <span class="keyword">inline</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <span class="keywordtype">float</span>&amp; a, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; b, <span class="keywordtype">float</span>&amp; result)<span class="keyword"> const </span>{</div><div class="line">            result = frac * a + (1.0 - frac) * b;</div><div class="line">        }</div><div class="line">        <span class="keywordtype">float</span> frac;</div><div class="line">    };</div><div class="line">}</div><div class="line">{</div><div class="line">    aTree.combine(bTree, Blend(0.25)); <span class="comment">// 0.25 * a + 0.75 * b</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3d84c2c10bb99b93dd6be52bf153b43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d84c2c10bb99b93dd6be52bf153b43b">&#9670;&nbsp;</a></span>combine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CombineOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prune</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af1cbd79b5ac7b0898386849c5d93e4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1cbd79b5ac7b0898386849c5d93e4cc">&#9670;&nbsp;</a></span>combine2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void combine2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherTreeType &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CombineOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prune</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For a given function <code>f</code>, use sparse traversal to compute <code>f(a, b)</code> over all corresponding pairs of values (tile or voxel) of trees A and B and store the result in this tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b</td><td>two trees with the same configuration (levels and node dimensions) as this tree but with the B tree possibly having a different value type </td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <code>void op(const T1&amp; a, const T2&amp; b, T1&amp; result)</code>, where <code>T1</code> is this tree's and the A tree's <code>ValueType</code> and <code>T2</code> is the B tree's <code>ValueType</code>, that computes <code>result = f(a, b)</code> </td></tr>
    <tr><td class="paramname">prune</td><td>if true, prune the resulting tree one branch at a time (this is usually more space-efficient than pruning the entire tree in one pass)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v6__2_1_1TypeError.html">TypeError</a></td><td>if the B tree's configuration doesn't match this tree's or if this tree's ValueType is not constructible from the B tree's ValueType.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd>Compute the per-voxel difference between two floating-point trees, <code>aTree</code> and <code>bTree</code>, and store the result in a third tree. <div class="fragment"><div class="line">{</div><div class="line">    <span class="keyword">struct </span>Local {</div><div class="line">        <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> diff(<span class="keyword">const</span> <span class="keywordtype">float</span>&amp; a, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; b, <span class="keywordtype">float</span>&amp; result) {</div><div class="line">            result = a - b;</div><div class="line">        }</div><div class="line">    };</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v6__2.html#a79a0127ad333d2a6201f025a0d9944f4">FloatTree</a> resultTree;</div><div class="line">    resultTree.combine2(aTree, bTree, Local::diff);</div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa5795706d9693640529f8a55ac1001fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5795706d9693640529f8a55ac1001fc">&#9670;&nbsp;</a></span>combine2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void combine2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherTreeType &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CombineOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prune</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a878302f18a7f23adac7da7a9fc5f7441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878302f18a7f23adac7da7a9fc5f7441">&#9670;&nbsp;</a></span>combine2Extended() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void combine2Extended </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherTreeType &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExtendedCombineOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prune</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#af1cbd79b5ac7b0898386849c5d93e4cc">combine2()</a>, but with </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b</td><td>two trees with the same configuration (levels and node dimensions) as this tree but with the B tree possibly having a different value type </td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <code>void op(CombineArgs&lt;T1, T2&gt;&amp; args)</code>, where <code>T1</code> is this tree's and the A tree's <code>ValueType</code> and <code>T2</code> is the B tree's <code>ValueType</code>, that computes <code>args.setResult(f(args.a(), args.b()))</code> and, optionally, <code>args.setResultIsActive(g(args.aIsActive(), args.bIsActive()))</code> for some functions <code>f</code> and <code>g</code> </td></tr>
    <tr><td class="paramname">prune</td><td>if true, prune the resulting tree one branch at a time (this is usually more space-efficient than pruning the entire tree in one pass) This variant passes not only the <em>a</em> and <em>b</em> values but also the active states of the <em>a</em> and <em>b</em> values to the functor, which may then return, by calling <code>args.setResultIsActive()</code>, a computed active state for the result value. By default, the result is active if either the <em>a</em> or the <em>b</em> value is active.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v6__2_1_1TypeError.html">TypeError</a></td><td>if the B tree's configuration doesn't match this tree's or if this tree's ValueType is not constructible from the B tree's ValueType.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Types_8h.html">openvdb/Types.h</a> for the definition of the <a class="el" href="classopenvdb_1_1v6__2_1_1CombineArgs.html" title="This struct collects both input and output arguments to &quot;grid combiner&quot; functors used with the tree::...">CombineArgs</a> struct.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd>Compute the per-voxel maximum values of two single-precision floating-point trees, <code>aTree</code> and <code>bTree</code>, and store the result in a third tree. Set the active state of each output value to that of the larger of the two input values. <div class="fragment"><div class="line">{</div><div class="line">    <span class="keyword">struct </span>Local {</div><div class="line">        <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespaceopenvdb_1_1v6__2_1_1tools_1_1composite.html#abe38a3dd950a6f3edd8dc4a23b5ec498">max</a>(CombineArgs&lt;float&gt;&amp; args) {</div><div class="line">            <span class="keywordflow">if</span> (args.b() &gt; args.a()) {</div><div class="line">                <span class="comment">// Transfer the B value and its active state.</span></div><div class="line">                args.setResult(args.b());</div><div class="line">                args.setResultIsActive(args.bIsActive());</div><div class="line">            } <span class="keywordflow">else</span> {</div><div class="line">                <span class="comment">// Preserve the A value and its active state.</span></div><div class="line">                args.setResult(args.a());</div><div class="line">                args.setResultIsActive(args.aIsActive());</div><div class="line">            }</div><div class="line">        }</div><div class="line">    };</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v6__2.html#a79a0127ad333d2a6201f025a0d9944f4">FloatTree</a> aTree = ...;</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v6__2.html#a79a0127ad333d2a6201f025a0d9944f4">FloatTree</a> bTree = ...;</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v6__2.html#a79a0127ad333d2a6201f025a0d9944f4">FloatTree</a> resultTree;</div><div class="line">    resultTree.combine2Extended(aTree, bTree, <a class="code" href="namespaceopenvdb_1_1v6__2_1_1tools_1_1composite.html#abe38a3dd950a6f3edd8dc4a23b5ec498">Local::max</a>);</div><div class="line">}</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example:</dt><dd>Compute the per-voxel maximum values of a double-precision and a single-precision floating-point tree, <code>aTree</code> and <code>bTree</code>, and store the result in a third, double-precision tree. Set the active state of each output value to that of the larger of the two input values. <div class="fragment"><div class="line">{</div><div class="line">    <span class="keyword">struct </span>Local {</div><div class="line">        <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespaceopenvdb_1_1v6__2_1_1tools_1_1composite.html#abe38a3dd950a6f3edd8dc4a23b5ec498">max</a>(CombineArgs&lt;double, float&gt;&amp; args) {</div><div class="line">            <span class="keywordflow">if</span> (args.b() &gt; args.a()) {</div><div class="line">                <span class="comment">// Transfer the B value and its active state.</span></div><div class="line">                args.setResult(args.b());</div><div class="line">                args.setResultIsActive(args.bIsActive());</div><div class="line">            } <span class="keywordflow">else</span> {</div><div class="line">                <span class="comment">// Preserve the A value and its active state.</span></div><div class="line">                args.setResult(args.a());</div><div class="line">                args.setResultIsActive(args.aIsActive());</div><div class="line">            }</div><div class="line">        }</div><div class="line">    };</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v6__2.html#a4bbf38a77dfd3bf2e63868af0638e2cc">DoubleTree</a> aTree = ...;</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v6__2.html#a79a0127ad333d2a6201f025a0d9944f4">FloatTree</a> bTree = ...;</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v6__2.html#a4bbf38a77dfd3bf2e63868af0638e2cc">DoubleTree</a> resultTree;</div><div class="line">    resultTree.combine2Extended(aTree, bTree, <a class="code" href="namespaceopenvdb_1_1v6__2_1_1tools_1_1composite.html#abe38a3dd950a6f3edd8dc4a23b5ec498">Local::max</a>);</div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a606623b3e96a1a62594583f54fdb30e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606623b3e96a1a62594583f54fdb30e0">&#9670;&nbsp;</a></span>combine2Extended() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void combine2Extended </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherTreeType &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtendedCombineOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prune</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71140d5e67f0fce2c7fe0ae119db9711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71140d5e67f0fce2c7fe0ae119db9711">&#9670;&nbsp;</a></span>combineExtended() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void combineExtended </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExtendedCombineOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prune</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a11ca864d49b3df73bd482307bd800577">combine()</a>, but with </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>a tree of the same type as this tree </td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <code>void op(CombineArgs&lt;ValueType&gt;&amp; args)</code> that computes <code>args.setResult(f(args.a(), args.b()))</code> and, optionally, <code>args.setResultIsActive(g(args.aIsActive(), args.bIsActive()))</code> for some functions <code>f</code> and <code>g</code> </td></tr>
    <tr><td class="paramname">prune</td><td>if true, prune the resulting tree one branch at a time (this is usually more space-efficient than pruning the entire tree in one pass)</td></tr>
  </table>
  </dd>
</dl>
<p>This variant passes not only the <em>a</em> and <em>b</em> values but also the active states of the <em>a</em> and <em>b</em> values to the functor, which may then return, by calling <code>args.setResultIsActive()</code>, a computed active state for the result value. By default, the result is active if either the <em>a</em> or the <em>b</em> value is active.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Types_8h.html">openvdb/Types.h</a> for the definition of the <a class="el" href="classopenvdb_1_1v6__2_1_1CombineArgs.html" title="This struct collects both input and output arguments to &quot;grid combiner&quot; functors used with the tree::...">CombineArgs</a> struct.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd>Replace voxel values in floating-point <code>aTree</code> with corresponding values from floating-point <code>bTree</code> (leaving <code>bTree</code> empty) wherever the <code>bTree</code> values are larger. Also, preserve the active states of any transferred values. <div class="fragment"><div class="line">{</div><div class="line">    <span class="keyword">struct </span>Local {</div><div class="line">        <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespaceopenvdb_1_1v6__2_1_1tools_1_1composite.html#abe38a3dd950a6f3edd8dc4a23b5ec498">max</a>(CombineArgs&lt;float&gt;&amp; args) {</div><div class="line">            <span class="keywordflow">if</span> (args.b() &gt; args.a()) {</div><div class="line">                <span class="comment">// Transfer the B value and its active state.</span></div><div class="line">                args.setResult(args.b());</div><div class="line">                args.setResultIsActive(args.bIsActive());</div><div class="line">            } <span class="keywordflow">else</span> {</div><div class="line">                <span class="comment">// Preserve the A value and its active state.</span></div><div class="line">                args.setResult(args.a());</div><div class="line">                args.setResultIsActive(args.aIsActive());</div><div class="line">            }</div><div class="line">        }</div><div class="line">    };</div><div class="line">    aTree.combineExtended(bTree, <a class="code" href="namespaceopenvdb_1_1v6__2_1_1tools_1_1composite.html#abe38a3dd950a6f3edd8dc4a23b5ec498">Local::max</a>);</div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa1557fead163be5539d36caffdbf0fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1557fead163be5539d36caffdbf0fb2">&#9670;&nbsp;</a></span>combineExtended() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void combineExtended </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtendedCombineOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prune</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a956efa074c97b4e8e3fe63b0832be5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956efa074c97b4e8e3fe63b0832be5f0">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#ab5e4dbbad02cb8050f56d4c9a9c8c937">TreeBase::Ptr</a> copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to a deep copy of this tree. </p>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#ab232ff56a020051ec076f1eff64a87ed">TreeBase</a>.</p>

</div>
</div>
<a id="abb399cd065108e53e7b65612e74372a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb399cd065108e53e7b65612e74372a5">&#9670;&nbsp;</a></span>denseFill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void denseFill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all voxels within a given axis-aligned box to a constant value and ensure that those voxels are all represented at the leaf level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>inclusive coordinates of opposite corners of an axis-aligned box. </td></tr>
    <tr><td class="paramname">value</td><td>the value to which to set voxels within the box. </td></tr>
    <tr><td class="paramname">active</td><td>if true, mark voxels within the box as active, otherwise mark them as inactive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a39a2211a02fb606e611d3ff5bbd6f50c" title="Densify active tiles, i.e., replace them with leaf-level active voxels. ">voxelizeActiveTiles()</a> </dd></dl>

</div>
</div>
<a id="a644718bb2fb240de962dc3c9a1fdf0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644718bb2fb240de962dc3c9a1fdf0dc">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if this tree contains no nodes other than the root node and no tiles other than background tiles. </p>

</div>
</div>
<a id="a0be8f5d220e6c9f76f6f443bba38d7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be8f5d220e6c9f76f6f443bba38d7af">&#9670;&nbsp;</a></span>evalActiveVoxelBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool evalActiveVoxelBoundingBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return in <em>bbox</em> the axis-aligned bounding box of all active voxels and tiles. </p>
<p>This method produces a more accurate, i.e. tighter, bounding box than evalLeafBoundingBox which is approximate but faster. </p><dl class="section return"><dt>Returns</dt><dd><code>false</code> if the bounding box is empty (in which case the bbox is set to its default value). </dd></dl>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#acc26c182dde6fc1b8e931b657ce70db4">TreeBase</a>.</p>

</div>
</div>
<a id="adb42ab1115f04d94d3d59da5c79c6e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb42ab1115f04d94d3d59da5c79c6e90">&#9670;&nbsp;</a></span>evalActiveVoxelDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool evalActiveVoxelDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return in <em>dim</em> the dimensions of the axis-aligned bounding box of all active voxels. This is a tighter bounding box than the leaf node bounding box. </p>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the bounding box is empty. </dd></dl>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#adcaf5e4a78bf63f11f82ac9eeed7e9c3">TreeBase</a>.</p>

</div>
</div>
<a id="ac33df3a47879d72c499c446e0d9fedea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33df3a47879d72c499c446e0d9fedea">&#9670;&nbsp;</a></span>evalLeafBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool evalLeafBoundingBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return in <em>bbox</em> the axis-aligned bounding box of all leaf nodes and active tiles. </p>
<p>This is faster than calling evalActiveVoxelBoundingBox, which visits the individual active voxels, and hence evalLeafBoundingBox produces a less tight, i.e. approximate, bbox. </p><dl class="section return"><dt>Returns</dt><dd><code>false</code> if the bounding box is empty (in which case the bbox is set to its default value). </dd></dl>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#adfe9509e850ee9d79c14e87fe15b0914">TreeBase</a>.</p>

</div>
</div>
<a id="ac8db9086dcfece9d64eab53bccdd30cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8db9086dcfece9d64eab53bccdd30cd">&#9670;&nbsp;</a></span>evalLeafDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool evalLeafDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return in <em>dim</em> the dimensions of the axis-aligned bounding box of all leaf nodes. </p>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the bounding box is empty. </dd></dl>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#ab5ed0caf71396fe4bb3d910370e80243">TreeBase</a>.</p>

</div>
</div>
<a id="a26f97e5be1f39947eb39b82285586d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f97e5be1f39947eb39b82285586d52">&#9670;&nbsp;</a></span>evalMinMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evalMinMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the minimum and maximum active values in this tree. </p>

</div>
</div>
<a id="a69bd60c87fb75e3bb7a9b5099f3a4bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69bd60c87fb75e3bb7a9b5099f3a4bdf">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all voxels within a given axis-aligned box to a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>inclusive coordinates of opposite corners of an axis-aligned box </td></tr>
    <tr><td class="paramname">value</td><td>the value to which to set voxels within the box </td></tr>
    <tr><td class="paramname">active</td><td>if true, mark voxels within the box as active, otherwise mark them as inactive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation generates a sparse, but not always optimally sparse, representation of the filled box. Follow fill operations with a <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a462c7056adc55d8da2cc5828934ff859" title="Reduce the memory footprint of this tree by replacing with tiles any nodes whose values are all the s...">prune()</a> operation for optimal sparseness. </dd></dl>

</div>
</div>
<a id="a032258988b41cc4ce0a3b310f45d5d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032258988b41cc4ce0a3b310f45d5d7d">&#9670;&nbsp;</a></span>getBackgroundValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1Metadata.html#ace3ea7af32684cd869611506ad3e12e8">Metadata::Ptr</a> getBackgroundValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this tree's background value wrapped as metadata. </p>
<dl class="section note"><dt>Note</dt><dd>Query the metadata object for the value's type. </dd></dl>

<p>Reimplemented from <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#a4fb6e76c14889fb7e3ee17259a495146">TreeBase</a>.</p>

</div>
</div>
<a id="ad588c2e8ac949143607f6455b86cf40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad588c2e8ac949143607f6455b86cf40b">&#9670;&nbsp;</a></span>getIndexRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getIndexRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Min and max are both inclusive. </p>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#a7ebd5e0acc5a803b85bf78b642ffd425">TreeBase</a>.</p>

</div>
</div>
<a id="ad3b91d6e713861046431c86630d23ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b91d6e713861046431c86630d23ae2">&#9670;&nbsp;</a></span>getNodeLog2Dims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getNodeLog2Dims </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v6__2.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse the type hierarchy of nodes, and return, in <em>dims</em>, a list of the Log2Dims of nodes in order from <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1RootNode.html">RootNode</a> to <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim...">LeafNode</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Because RootNodes are resizable, the <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1RootNode.html">RootNode</a> Log2Dim is 0 for all trees. </dd></dl>

</div>
</div>
<a id="a33a3cd99c0b9c78e1f6da3d9a36fdaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a3cd99c0b9c78e1f6da3d9a36fdaff">&#9670;&nbsp;</a></span>getNodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getNodes </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds all nodes of a certain type to a container with the following API: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ArrayT {</div><div class="line">   <span class="keyword">using</span> value_type = ...;             <span class="comment">// the type of node to be added to the array</span></div><div class="line">   <span class="keywordtype">void</span> push_back(value_type nodePtr); <span class="comment">// add a node to the array</span></div><div class="line">};</div></div><!-- fragment --><p>An example of a wrapper around a c-style array is: </p><div class="fragment"><div class="line"> <span class="keyword">struct </span>MyArray {</div><div class="line">    <span class="keyword">using</span> value_type = LeafType*;</div><div class="line">    value_type* ptr;</div><div class="line">    MyArray(value_type* array) : ptr(array) {}</div><div class="line">    <span class="keywordtype">void</span> push_back(value_type leaf) { *ptr++ = leaf; }</div><div class="line">};</div></div><!-- fragment --><p>An example that constructs a list of pointer to all leaf nodes is: </p><div class="fragment"><div class="line">std::vector&lt;const LeafNodeType*&gt; array;<span class="comment">//most std contains have the required API</span></div><div class="line">array.reserve(tree.leafCount());<span class="comment">//this is a fast preallocation.</span></div><div class="line">tree.getNodes(array);</div></div><!-- fragment --> 
</div>
</div>
<a id="ab6a64f33ad83ba0854b8502a061eb30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a64f33ad83ba0854b8502a061eb30b">&#9670;&nbsp;</a></span>getNodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getNodes </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds all nodes of a certain type to a container with the following API: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ArrayT {</div><div class="line">   <span class="keyword">using</span> value_type = ...;             <span class="comment">// the type of node to be added to the array</span></div><div class="line">   <span class="keywordtype">void</span> push_back(value_type nodePtr); <span class="comment">// add a node to the array</span></div><div class="line">};</div></div><!-- fragment --><p>An example of a wrapper around a c-style array is: </p><div class="fragment"><div class="line"> <span class="keyword">struct </span>MyArray {</div><div class="line">    <span class="keyword">using</span> value_type = LeafType*;</div><div class="line">    value_type* ptr;</div><div class="line">    MyArray(value_type* array) : ptr(array) {}</div><div class="line">    <span class="keywordtype">void</span> push_back(value_type leaf) { *ptr++ = leaf; }</div><div class="line">};</div></div><!-- fragment --><p>An example that constructs a list of pointer to all leaf nodes is: </p><div class="fragment"><div class="line">std::vector&lt;const LeafNodeType*&gt; array;<span class="comment">//most std contains have the required API</span></div><div class="line">array.reserve(tree.leafCount());<span class="comment">//this is a fast preallocation.</span></div><div class="line">tree.getNodes(array);</div></div><!-- fragment --> 
</div>
</div>
<a id="a96003dd5795749675766804a5a618f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96003dd5795749675766804a5a618f9b">&#9670;&nbsp;</a></span>getValue() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const RootNodeType::ValueType &amp; getValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the voxel at the given coordinates. </p>

</div>
</div>
<a id="a887eb7998c9926f06eab7de2ee7cf947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887eb7998c9926f06eab7de2ee7cf947">&#9670;&nbsp;</a></span>getValue() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a>&amp; getValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessT &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of the voxel at the given coordinates and update the given accessor's node cache. </p>

</div>
</div>
<a id="a54ed3f7da1f8419a8af8171677116a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ed3f7da1f8419a8af8171677116a2b">&#9670;&nbsp;</a></span>getValue() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const RootNodeType::ValueType&amp; getValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessT &amp;&#160;</td>
          <td class="paramname"><em>accessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03c8f00f509936998e0d47be7afd5e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c8f00f509936998e0d47be7afd5e3f">&#9670;&nbsp;</a></span>getValueDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getValueDepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the tree depth (0 = root) at which the value of voxel (x, y, z) resides. </p>
<p>If (x, y, z) isn't explicitly represented in the tree (i.e., it is implicitly a background voxel), return -1. </p>

</div>
</div>
<a id="ae27c5b1e634724be621234d2653c8eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27c5b1e634724be621234d2653c8eae">&#9670;&nbsp;</a></span>hasActiveTiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasActiveTiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if this tree has any active tiles. </p>

</div>
</div>
<a id="a0533c7394aa18dbf9c65d6573cf0656f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0533c7394aa18dbf9c65d6573cf0656f">&#9670;&nbsp;</a></span>hasSameTopology()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasSameTopology </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; OtherRootNodeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the given tree has the same node and active value topology as this tree, whether or not it has the same <code>ValueType</code>. </p>

</div>
</div>
<a id="a689a5c4f6bbbb15831a4f53438e63929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689a5c4f6bbbb15831a4f53438e63929">&#9670;&nbsp;</a></span>inactiveLeafVoxelCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v6__2.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> inactiveLeafVoxelCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of inactive voxels stored in leaf nodes. </p>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#aa682010a0d4f996171ae710d1c353d11">TreeBase</a>.</p>

</div>
</div>
<a id="a62f9cac4988865277566d8d71ef85365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f9cac4988865277566d8d71ef85365">&#9670;&nbsp;</a></span>inactiveVoxelCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v6__2.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> inactiveVoxelCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of inactive voxels within the bounding box of all active voxels. </p>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#a9653eb3c8d8e1a6a148e0df7bb618234">TreeBase</a>.</p>

</div>
</div>
<a id="ae965878865e08511fc2e16abc00b64c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae965878865e08511fc2e16abc00b64c1">&#9670;&nbsp;</a></span>isValueOff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isValueOff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the value at the given coordinates is inactive. </p>

</div>
</div>
<a id="a149d3646dfe8b0ae5f352cea5c1e9cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149d3646dfe8b0ae5f352cea5c1e9cc7">&#9670;&nbsp;</a></span>isValueOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isValueOn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the value at the given coordinates is active. </p>

</div>
</div>
<a id="a5ee8f6c345a7611cf70f10361c6248f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee8f6c345a7611cf70f10361c6248f0">&#9670;&nbsp;</a></span>leafCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v6__2.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> leafCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of leaf nodes. </p>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#a7f3ef6cf016b0fbc3473d3dee3813bf8">TreeBase</a>.</p>

</div>
</div>
<a id="a237bd8c635a56232570358f99e922328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237bd8c635a56232570358f99e922328">&#9670;&nbsp;</a></span>memUsage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v6__2.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> memUsage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total amount of memory in bytes occupied by this tree. </p>

<p>Reimplemented from <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#aa7aa0e6d078aad781b8859f08073d196">TreeBase</a>.</p>

</div>
</div>
<a id="a2ba5f332b68e4a1ebba9dbf4b95ec807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba5f332b68e4a1ebba9dbf4b95ec807">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v6__2.html#ade9c95ac55c647839e6f3e9b462c0575">MergePolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em> = <code><a class="el" href="namespaceopenvdb_1_1v6__2.html#ade9c95ac55c647839e6f3e9b462c0575a89c44945b26534bc1d5ede51c342400e">MERGE_ACTIVE_STATES</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Efficiently merge another tree into this tree using one of several schemes. </p>
<p>This operation is primarily intended to combine trees that are mostly non-overlapping (for example, intermediate trees from computations that are parallelized across disjoint regions of space). </p><dl class="section note"><dt>Note</dt><dd>This operation is not guaranteed to produce an optimally sparse tree. Follow <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2ba5f332b68e4a1ebba9dbf4b95ec807" title="Efficiently merge another tree into this tree using one of several schemes. ">merge()</a> with <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a462c7056adc55d8da2cc5828934ff859" title="Reduce the memory footprint of this tree by replacing with tiles any nodes whose values are all the s...">prune()</a> for optimal sparseness. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operation always empties the other tree. </dd></dl>

</div>
</div>
<a id="aa6954a428c0ef18a03431f251f4e7d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6954a428c0ef18a03431f251f4e7d24">&#9670;&nbsp;</a></span>modifyValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void modifyValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ModifyOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a functor to the value of the voxel at the given coordinates and mark the voxel as active. </p>
<p>Provided that the functor can be inlined, this is typically significantly faster than calling <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a96003dd5795749675766804a5a618f9b" title="Return the value of the voxel at the given coordinates. ">getValue()</a> followed by <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad6cf12f28a771762327ba1578bc48e9c" title="Mark the voxel at the given coordinates as active but don&#39;t change its value. ">setValueOn()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xyz</td><td>the coordinates of a voxel whose value is to be modified </td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <code>void op(ValueType&amp;) const</code> that modifies its argument in place </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">Coord xyz(1, 0, -2);</div><div class="line"><span class="comment">// Multiply the value of a voxel by a constant and mark the voxel as active.</span></div><div class="line">floatTree.modifyValue(xyz, [](<span class="keywordtype">float</span>&amp; f) { f *= 0.25; }); <span class="comment">// C++11</span></div><div class="line"><span class="comment">// Set the value of a voxel to the maximum of its current value and 0.25,</span></div><div class="line"><span class="comment">// and mark the voxel as active.</span></div><div class="line">floatTree.modifyValue(xyz, [](<span class="keywordtype">float</span>&amp; f) { f = <a class="code" href="namespaceopenvdb_1_1v6__2_1_1tools_1_1composite.html#abe38a3dd950a6f3edd8dc4a23b5ec498">std::max</a>(f, 0.25f); }); <span class="comment">// C++11</span></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The functor is not guaranteed to be called only once. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceopenvdb_1_1v6__2_1_1tools.html#ada1c7e219f36d148510ce22d7599171b">tools::foreach()</a> </dd></dl>

</div>
</div>
<a id="a5cb69af7e17c3a9a6d6dc360c878448c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb69af7e17c3a9a6d6dc360c878448c">&#9670;&nbsp;</a></span>modifyValueAndActiveState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void modifyValueAndActiveState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ModifyOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a functor to the voxel at the given coordinates. </p>
<p>Provided that the functor can be inlined, this is typically significantly faster than calling <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a96003dd5795749675766804a5a618f9b" title="Return the value of the voxel at the given coordinates. ">getValue()</a> followed by <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a83302a39df403b0b10ffcadac5856916" title="Set the value of the voxel at the given coordinates and mark the voxel as active. ...">setValue()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xyz</td><td>the coordinates of a voxel to be modified </td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <code>void op(ValueType&amp;, bool&amp;) const</code> that modifies its arguments, a voxel's value and active state, in place </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">Coord xyz(1, 0, -2);</div><div class="line"><span class="comment">// Multiply the value of a voxel by a constant and mark the voxel as inactive.</span></div><div class="line">floatTree.modifyValueAndActiveState(xyz,</div><div class="line">    [](<span class="keywordtype">float</span>&amp; f, <span class="keywordtype">bool</span>&amp; b) { f *= 0.25; b = <span class="keyword">false</span>; }); <span class="comment">// C++11</span></div><div class="line"><span class="comment">// Set the value of a voxel to the maximum of its current value and 0.25,</span></div><div class="line"><span class="comment">// but don&#39;t change the voxel&#39;s active state.</span></div><div class="line">floatTree.modifyValueAndActiveState(xyz,</div><div class="line">    [](<span class="keywordtype">float</span>&amp; f, <span class="keywordtype">bool</span>&amp;) { f = <a class="code" href="namespaceopenvdb_1_1v6__2_1_1tools_1_1composite.html#abe38a3dd950a6f3edd8dc4a23b5ec498">std::max</a>(f, 0.25f); }); <span class="comment">// C++11</span></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The functor is not guaranteed to be called only once. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceopenvdb_1_1v6__2_1_1tools.html#ada1c7e219f36d148510ce22d7599171b">tools::foreach()</a> </dd></dl>

</div>
</div>
<a id="aea494a915911bbde5e5a9eb26d89bec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea494a915911bbde5e5a9eb26d89bec1">&#9670;&nbsp;</a></span>nonLeafCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v6__2.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> nonLeafCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of non-leaf nodes. </p>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#a11d3e40260ba955b4a19778072e684b0">TreeBase</a>.</p>

</div>
</div>
<a id="a3dc5125f182645c0dc5f473440619b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc5125f182645c0dc5f473440619b10">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ddc9d21426bff9261068aec40d85b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddc9d21426bff9261068aec40d85b39">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ffa08696ac4169c485f707fff7a5861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffa08696ac4169c485f707fff7a5861">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0a2493ba6f01768bfd929f8e9e6e21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a2493ba6f01768bfd929f8e9e6e21c">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>std::cout</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verboseLevel</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print statistics, memory usage and other information about this tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>a stream to which to write textual information </td></tr>
    <tr><td class="paramname">verboseLevel</td><td>1: print tree configuration only; 2: include node and voxel statistics; 3: include memory usage; 4: include minimum and maximum voxel values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd><em>verboseLevel</em> 4 forces loading of any unallocated nodes. </dd></dl>

<p>Reimplemented from <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#a632380b0a782c08de6b8d0ffc6efee54">TreeBase</a>.</p>

</div>
</div>
<a id="a21747eeca7dea89fcf3aa2cad2bf76f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21747eeca7dea89fcf3aa2cad2bf76f2">&#9670;&nbsp;</a></span>probeConstLeaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const RootNodeType::LeafNodeType * probeConstLeaf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>. </p>

</div>
</div>
<a id="ae1b9323b7d38a7ef15a890cf582e5b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b9323b7d38a7ef15a890cf582e5b79">&#9670;&nbsp;</a></span>probeConstNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const NodeType * probeConstNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the node of type <code>NodeType</code> that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>. </p>

</div>
</div>
<a id="a48bab17c2781af76eacbc64ba399e1d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bab17c2781af76eacbc64ba399e1d7">&#9670;&nbsp;</a></span>probeLeaf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RootNodeType::LeafNodeType * probeLeaf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>. </p>

</div>
</div>
<a id="ac21a2d47ff0aecdaf336389ad95c466d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21a2d47ff0aecdaf336389ad95c466d">&#9670;&nbsp;</a></span>probeLeaf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ad69afaa4f94a67ce2f7d0b18b339291e">LeafNodeType</a>* probeLeaf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>. </p>

</div>
</div>
<a id="a1096806c2a3867c6a168981093c5a0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1096806c2a3867c6a168981093c5a0fe">&#9670;&nbsp;</a></span>probeNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeType * probeNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the node of type <code>NodeType</code> that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>. </p>

</div>
</div>
<a id="a10e35932262eb2206e2b87797105d2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e35932262eb2206e2b87797105d2b3">&#9670;&nbsp;</a></span>probeNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const NodeType * probeNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the node of type <code>NodeType</code> that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>. </p>

</div>
</div>
<a id="a7ac3a88741d49d74b50c55b9a5371646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac3a88741d49d74b50c55b9a5371646">&#9670;&nbsp;</a></span>probeValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool probeValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the voxel at the given coordinates. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is active. </dd></dl>

</div>
</div>
<a id="a462c7056adc55d8da2cc5828934ff859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462c7056adc55d8da2cc5828934ff859">&#9670;&nbsp;</a></span>prune()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void prune </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespaceopenvdb_1_1v6__2.html#a92d064b9b9b524a9db16b22a22293068">zeroVal</a>&lt;<a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce the memory footprint of this tree by replacing with tiles any nodes whose values are all the same (optionally to within a tolerance) and have the same active state. </p>
<dl class="section warning"><dt>Warning</dt><dd>Will soon be deprecated! </dd></dl>

</div>
</div>
<a id="ad67a4ef3e29a1d58159e18cb0fce0515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67a4ef3e29a1d58159e18cb0fce0515">&#9670;&nbsp;</a></span>readBuffers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void readBuffers </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveFloatAsHalf</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read all data buffers for this tree. </p>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#a355f88e882ef5bab882472098c912ab1">TreeBase</a>.</p>

</div>
</div>
<a id="a347a003931da1fe21c904f52322a3a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347a003931da1fe21c904f52322a3a00">&#9670;&nbsp;</a></span>readBuffers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void readBuffers </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveFloatAsHalf</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read all of this tree's data buffers that intersect the given bounding box. </p>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#a6e32458712135f1dee4d084c88c9b23d">TreeBase</a>.</p>

</div>
</div>
<a id="aaa0416e0758e74661727eb9d3c46b528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0416e0758e74661727eb9d3c46b528">&#9670;&nbsp;</a></span>readNonresidentBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void readNonresidentBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read all of this tree's data buffers that are not yet resident in memory (because delayed loading is in effect). </p>
<p>If this tree was read from a memory-mapped file, this operation disconnects the tree from the file. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#ae68f15390dfa328e07ae1a372deb1139" title="Replace with background tiles any nodes whose voxel buffers have not yet been allocated. ">clipUnallocatedNodes</a>, <a class="el" href="classopenvdb_1_1v6__2_1_1io_1_1File.html#ab9e653cf43c03bbfe0decd34494892ca" title="Open the file, read the file header and the file-level metadata, and populate the grid descriptors...">io::File::open</a>, <a class="el" href="classopenvdb_1_1v6__2_1_1io_1_1MappedFile.html" title="Handle to control the lifetime of a memory-mapped .vdb file. ">io::MappedFile</a> </dd></dl>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#aa3282e612fc0505e919401f5c538c89b">TreeBase</a>.</p>

</div>
</div>
<a id="a007631c53f0e3e44457f2f72fd22323d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007631c53f0e3e44457f2f72fd22323d">&#9670;&nbsp;</a></span>readTopology()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void readTopology </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveFloatAsHalf</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the tree topology from a stream. </p>
<p>This will read the tree structure and tile values, but not voxel data. </p>

<p>Reimplemented from <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#afc88b0cf680670594c72aa4ddba1336e">TreeBase</a>.</p>

</div>
</div>
<a id="a4a7a9efd8a2eb16533f0c77f28ae162b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7a9efd8a2eb16533f0c77f28ae162b">&#9670;&nbsp;</a></span>releaseAccessor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void releaseAccessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt;, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>accessor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deregister an accessor so that it is no longer automatically cleared. </p>

</div>
</div>
<a id="a793d13ab6b6648f44762370a36807b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793d13ab6b6648f44762370a36807b9e">&#9670;&nbsp;</a></span>releaseAccessor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void releaseAccessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt;, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>accessor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deregister an accessor so that it is no longer automatically cleared. </p>

</div>
</div>
<a id="a0ff7b9c537368ef9f40548ea68675a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff7b9c537368ef9f40548ea68675a4a">&#9670;&nbsp;</a></span>releaseAccessor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void releaseAccessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt;, false &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dummy implementations. </p>

</div>
</div>
<a id="a1330f899e7de32d5f3ed6e48332c4fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1330f899e7de32d5f3ed6e48332c4fce">&#9670;&nbsp;</a></span>releaseAccessor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void releaseAccessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a>&lt; const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; _RootNodeType &gt;, false &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dummy implementations. </p>

</div>
</div>
<a id="a7cb55df5cf1166cdd2873baa6259658f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb55df5cf1166cdd2873baa6259658f">&#9670;&nbsp;</a></span>releaseAllAccessors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void releaseAllAccessors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify all registered accessors, by calling ValueAccessor::release(), that this tree is about to be deleted. </p>

</div>
</div>
<a id="a1969dd5ae7c1715c8abcfcd82aeeff85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1969dd5ae7c1715c8abcfcd82aeeff85">&#9670;&nbsp;</a></span>root() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2bfd3918f8d5734228a8a97392a91176">RootNodeType</a>&amp; root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this tree's root node. </p>

</div>
</div>
<a id="aef2f3617212eb5a8e9fcb276f812b995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2f3617212eb5a8e9fcb276f812b995">&#9670;&nbsp;</a></span>root() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2bfd3918f8d5734228a8a97392a91176">RootNodeType</a>&amp; root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this tree's root node. </p>

</div>
</div>
<a id="a7b3e82eb582914ac6f31f32fea77292f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3e82eb582914ac6f31f32fea77292f">&#9670;&nbsp;</a></span>setActiveState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setActiveState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the active state of the voxel at the given coordinates but don't change its value. </p>

</div>
</div>
<a id="a83302a39df403b0b10ffcadac5856916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83302a39df403b0b10ffcadac5856916">&#9670;&nbsp;</a></span>setValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates and mark the voxel as active. </p>

</div>
</div>
<a id="acbf7e55fdc58f2c5d03395bffe10410e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf7e55fdc58f2c5d03395bffe10410e">&#9670;&nbsp;</a></span>setValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessT &amp;&#160;</td>
          <td class="paramname"><em>accessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates, mark the voxel as active, and update the given accessor's node cache. </p>

</div>
</div>
<a id="a8a91d631df8f64f84a0aad7436cb11f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a91d631df8f64f84a0aad7436cb11f3">&#9670;&nbsp;</a></span>setValueOff() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the voxel at the given coordinates as inactive but don't change its value. </p>

</div>
</div>
<a id="a73a6e7c85d37e7d677eddc3cce8aa11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a6e7c85d37e7d677eddc3cce8aa11b">&#9670;&nbsp;</a></span>setValueOff() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates and mark the voxel as inactive. </p>

</div>
</div>
<a id="ad6cf12f28a771762327ba1578bc48e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6cf12f28a771762327ba1578bc48e9c">&#9670;&nbsp;</a></span>setValueOn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the voxel at the given coordinates as active but don't change its value. </p>

</div>
</div>
<a id="ae95653046c85afb743075f139a26df9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95653046c85afb743075f139a26df9d">&#9670;&nbsp;</a></span>setValueOn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates and mark the voxel as active. </p>

</div>
</div>
<a id="a63ff695beda11ed9ef625a28ce8a5faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ff695beda11ed9ef625a28ce8a5faf">&#9670;&nbsp;</a></span>setValueOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOnly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates but don't change its active state. </p>

</div>
</div>
<a id="ad87de532e553a73bd6e3b55337eff1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87de532e553a73bd6e3b55337eff1d5">&#9670;&nbsp;</a></span>sparseFill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparseFill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all voxels within a given axis-aligned box to a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>inclusive coordinates of opposite corners of an axis-aligned box </td></tr>
    <tr><td class="paramname">value</td><td>the value to which to set voxels within the box </td></tr>
    <tr><td class="paramname">active</td><td>if true, mark voxels within the box as active, otherwise mark them as inactive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation generates a sparse, but not always optimally sparse, representation of the filled box. Follow fill operations with a <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a462c7056adc55d8da2cc5828934ff859" title="Reduce the memory footprint of this tree by replacing with tiles any nodes whose values are all the s...">prune()</a> operation for optimal sparseness. </dd></dl>

</div>
</div>
<a id="a0f336548f0b7d3e0debadf68d43602b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f336548f0b7d3e0debadf68d43602b6">&#9670;&nbsp;</a></span>stealNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeT * stealNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the node of type <code>NodeT</code> that contains voxel (x, y, z) and replace it with a tile of the specified value and state. If no such node exists, leave the tree unchanged and return <code>nullptr</code>. </p>
<dl class="section note"><dt>Note</dt><dd>The caller takes ownership of the node and is responsible for deleting it. </dd></dl>

</div>
</div>
<a id="ae9865f5a8eabf75fc2ad06581e22edcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9865f5a8eabf75fc2ad06581e22edcd">&#9670;&nbsp;</a></span>stealNodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stealNodes </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Steals all nodes of a certain type from the tree and adds them to a container with the following API: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ArrayT {</div><div class="line">   <span class="keyword">using</span> value_type = ...;             <span class="comment">// the type of node to be added to the array</span></div><div class="line">   <span class="keywordtype">void</span> push_back(value_type nodePtr); <span class="comment">// add a node to the array</span></div><div class="line">};</div></div><!-- fragment --><p>An example of a wrapper around a c-style array is: </p><div class="fragment"><div class="line"> <span class="keyword">struct </span>MyArray {</div><div class="line">    <span class="keyword">using</span> value_type = LeafType*;</div><div class="line">    value_type* ptr;</div><div class="line">    MyArray(value_type* array) : ptr(array) {}</div><div class="line">    <span class="keywordtype">void</span> push_back(value_type leaf) { *ptr++ = leaf; }</div><div class="line">};</div></div><!-- fragment --><p>An example that constructs a list of pointer to all leaf nodes is: </p><div class="fragment"><div class="line">std::vector&lt;const LeafNodeType*&gt; array;<span class="comment">//most std contains have the required API</span></div><div class="line">array.reserve(tree.leafCount());<span class="comment">//this is a fast preallocation.</span></div><div class="line">tree.stealNodes(array);</div></div><!-- fragment --> 
</div>
</div>
<a id="ac4a8fd1479bd7b61a23884680d5d49e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a8fd1479bd7b61a23884680d5d49e0">&#9670;&nbsp;</a></span>stealNodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stealNodes </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a9575d20614e2fac00e43c5fd4fd6f32b">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c6ad1abf61c3b13d7ad7408f4634226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6ad1abf61c3b13d7ad7408f4634226">&#9670;&nbsp;</a></span>topologyDifference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void topologyDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; OtherRootNodeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Difference this tree's set of active values with the active values of the other tree, whose <code>ValueType</code> may be different. So a resulting voxel will be active only if the original voxel is active in this tree and inactive in the other tree. </p>
<dl class="section note"><dt>Note</dt><dd>This operation can delete branches in this grid if they overlap with active tiles in the other grid. Likewise active voxels can be turned into inactive voxels resulting in leaf nodes with no active values. Thus, it is recommended to subsequently call <a class="el" href="namespaceopenvdb_1_1v6__2_1_1tools.html#ae81e76930df0c635a4e175887352257e" title="Reduce the memory footprint of a tree by replacing with background tiles any nodes whose values are a...">tools::pruneInactive</a>. </dd></dl>

</div>
</div>
<a id="a4a4089e30211443f0d6431cff8bef3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4089e30211443f0d6431cff8bef3cc">&#9670;&nbsp;</a></span>topologyIntersection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void topologyIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; OtherRootNodeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intersects this tree's set of active values with the active values of the other tree, whose <code>ValueType</code> may be different. </p>
<p>The resulting state of a value is active only if the corresponding value was already active AND if it is active in the other tree. Also, a resulting value maps to a voxel if the corresponding value already mapped to an active voxel in either of the two grids and it maps to an active tile or voxel in the other grid.</p>
<dl class="section note"><dt>Note</dt><dd>This operation can delete branches in this grid if they overlap with inactive tiles in the other grid. Likewise active voxels can be turned into unactive voxels resulting in leaf nodes with no active values. Thus, it is recommended to subsequently call <a class="el" href="namespaceopenvdb_1_1v6__2_1_1tools.html#ae81e76930df0c635a4e175887352257e" title="Reduce the memory footprint of a tree by replacing with background tiles any nodes whose values are a...">tools::pruneInactive</a>. </dd></dl>

</div>
</div>
<a id="ac32b595dbcad270a15ed20df549c946f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32b595dbcad270a15ed20df549c946f">&#9670;&nbsp;</a></span>topologyUnion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void topologyUnion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html">Tree</a>&lt; OtherRootNodeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Union this tree's set of active values with the active values of the other tree, whose <code>ValueType</code> may be different. </p>
<p>The resulting state of a value is active if the corresponding value was already active OR if it is active in the other tree. Also, a resulting value maps to a voxel if the corresponding value already mapped to a voxel OR if it is a voxel in the other tree. Thus, a resulting value can only map to a tile if the corresponding value already mapped to a tile AND if it is a tile value in other tree.</p>
<dl class="section note"><dt>Note</dt><dd>This operation modifies only active states, not values. Specifically, active tiles and voxels in this tree are not changed, and tiles or voxels that were inactive in this tree but active in the other tree are marked as active in this tree but left with their original values. </dd></dl>

</div>
</div>
<a id="a4b094186577cde9b7ad1f326389c815f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b094186577cde9b7ad1f326389c815f">&#9670;&nbsp;</a></span>touchLeaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RootNodeType::LeafNodeType * touchLeaf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, create one that preserves the values and active states of all voxels. </p>
<p>Use this method to preallocate a static tree topology over which to safely perform multithreaded processing. </p>

</div>
</div>
<a id="af2efbad063f9f8cd68f260ebf06f9ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2efbad063f9f8cd68f260ebf06f9ad8">&#9670;&nbsp;</a></span>treeDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v6__2.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> treeDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the depth of this tree. </p>
<p>A tree with only a root node and leaf nodes has depth 2, for example. </p>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#ace18fe0a4642b592421789ed2f371a63">TreeBase</a>.</p>

</div>
</div>
<a id="a34b9eb7da4505530a4199fa0a55ccf20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b9eb7da4505530a4199fa0a55ccf20">&#9670;&nbsp;</a></span>treeType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceopenvdb_1_1v6__2.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp; treeType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the name of this type of tree. </p>

</div>
</div>
<a id="a8a1417546ed9bc3e5a3daa3f2bde001a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1417546ed9bc3e5a3daa3f2bde001a">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceopenvdb_1_1v6__2.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a>&amp; type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the name of this type of tree. </p>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#a5b3a00bb536b37d30bf04307b3fa15ec">TreeBase</a>.</p>

</div>
</div>
<a id="ae386cb138ff84e81f8c7d594d4acd851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae386cb138ff84e81f8c7d594d4acd851">&#9670;&nbsp;</a></span>unallocatedLeafCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v6__2.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> unallocatedLeafCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total number of unallocated leaf nodes residing in this tree. </p>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#a872af55816c7121ade4063f3a2988a4f">TreeBase</a>.</p>

</div>
</div>
<a id="aecf5c7a62c61dc964ae5e972d15a7470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf5c7a62c61dc964ae5e972d15a7470">&#9670;&nbsp;</a></span>valueType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v6__2.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> valueType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the name of the type of a voxel's value (e.g., "float" or "vec3d") </p>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#a01a396e41a8f7deb454d75523d7deea5">TreeBase</a>.</p>

</div>
</div>
<a id="a92fa8714e1d4021da4f150b5e24385a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92fa8714e1d4021da4f150b5e24385a0">&#9670;&nbsp;</a></span>visit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit </td>
          <td>(</td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Traverse this tree in depth-first order, and at each node call the given functor with a <code>DenseIterator</code> (see <a class="el" href="Iterator_8h.html">Iterator.h</a>) that points to either a child node or a tile value. If the iterator points to a child node and the functor returns true, do not descend to the child node; instead, continue the traversal at the next iterator position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>a functor of the form <code>template&lt;typename IterT&gt; bool op(IterT&amp;)</code>, where <code>IterT</code> is either a <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1RootNode.html#a01bb1bcecd7385c19f214c7dd217fb27">RootNode::ChildAllIter</a>, an <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1InternalNode.html#ace35dd5a583a8891d972fab967cf3d57">InternalNode::ChildAllIter</a> or a <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1LeafNode.html#afb0f2a243597427407203e2d697562c9">LeafNode::ChildAllIter</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>There is no iterator that points to a <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1RootNode.html">RootNode</a>, so to visit the root node, retrieve the <code>parent()</code> of a <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1RootNode.html#a01bb1bcecd7385c19f214c7dd217fb27">RootNode::ChildAllIter</a>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd>Print information about the nodes and tiles of a tree, but not individual voxels. <div class="fragment"><div class="line"><span class="keyword">namespace </span>{</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TreeT&gt;</div><div class="line">    <span class="keyword">struct </span>PrintTreeVisitor</div><div class="line">    {</div><div class="line">        <span class="keyword">using</span> RootT = <span class="keyword">typename</span> TreeT::RootNodeType;</div><div class="line">        <span class="keywordtype">bool</span> visitedRoot;</div><div class="line"></div><div class="line">        PrintTreeVisitor(): visitedRoot(false) {}</div><div class="line"></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</div><div class="line">        <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator()(IterT&amp; iter)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (!visitedRoot &amp;&amp; iter.parent().getLevel() == RootT::LEVEL) {</div><div class="line">                visitedRoot = <span class="keyword">true</span>;</div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Level-&quot;</span> &lt;&lt; RootT::LEVEL &lt;&lt; <span class="stringliteral">&quot; node&quot;</span> &lt;&lt; std::endl;</div><div class="line">            }</div><div class="line">            <span class="keyword">typename</span> IterT::NonConstValueType value;</div><div class="line">            <span class="keyword">typename</span> IterT::ChildNodeType* child = iter.probeChild(value);</div><div class="line">            <span class="keywordflow">if</span> (child == <span class="keyword">nullptr</span>) {</div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Tile with value &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</div><div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// no child to visit, so stop descending</span></div><div class="line">            }</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Level-&quot;</span> &lt;&lt; child-&gt;getLevel() &lt;&lt; <span class="stringliteral">&quot; node&quot;</span> &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">return</span> (child-&gt;getLevel() == 0); <span class="comment">// don&#39;t visit leaf nodes</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// The generic method, above, calls iter.probeChild(), which is not defined</span></div><div class="line">        <span class="comment">// for LeafNode::ChildAllIter.  These overloads ensure that the generic</span></div><div class="line">        <span class="comment">// method template doesn&#39;t get instantiated for LeafNode iterators.</span></div><div class="line">        <span class="keywordtype">bool</span> operator()(<span class="keyword">typename</span> TreeT::LeafNodeType::ChildAllIter&amp;) { <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div><div class="line">        <span class="keywordtype">bool</span> operator()(<span class="keyword">typename</span> TreeT::LeafNodeType::ChildAllCIter&amp;) { <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div><div class="line">    };</div><div class="line">}</div><div class="line">{</div><div class="line">    PrintTreeVisitor visitor;</div><div class="line">    tree.visit(visitor);</div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab5edcc00e9c808a70cf54f70d1c6cf1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5edcc00e9c808a70cf54f70d1c6cf1c">&#9670;&nbsp;</a></span>visit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit </td>
          <td>(</td>
          <td class="paramtype">const VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca906e71df15cfed732dc0fd44f01c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca906e71df15cfed732dc0fd44f01c37">&#9670;&nbsp;</a></span>visit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit </td>
          <td>(</td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a92fa8714e1d4021da4f150b5e24385a0">visit()</a>, but using <code>const</code> iterators, i.e., with </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>a functor of the form <code>template&lt;typename IterT&gt; bool op(IterT&amp;)</code>, where <code>IterT</code> is either a <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1RootNode.html#aba3a2d9f84085e3e6b54f4358df5eb28">RootNode::ChildAllCIter</a>, an <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1InternalNode.html#aa08445224256785ccda0b3c3f8d6ffa3">InternalNode::ChildAllCIter</a> or a <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1LeafNode.html#a05f42aaba32304971f34f8fc0a355424">LeafNode::ChildAllCIter</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1043a1492b198e8f675b9fd8fafce4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1043a1492b198e8f675b9fd8fafce4d">&#9670;&nbsp;</a></span>visit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit </td>
          <td>(</td>
          <td class="paramtype">const VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a669237d39f3536882fd6c16fb32fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a669237d39f3536882fd6c16fb32fde">&#9670;&nbsp;</a></span>visit2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit2 </td>
          <td>(</td>
          <td class="paramtype">OtherTreeType &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Traverse this tree and another tree in depth-first order, and for corresponding subregions of index space call the given functor with two <code>DenseIterators</code> (see <a class="el" href="Iterator_8h.html">Iterator.h</a>), each of which points to either a child node or a tile value of this tree and the other tree. If the A iterator points to a child node and the functor returns a nonzero value with bit 0 set (e.g., 1), do not descend to the child node; instead, continue the traversal at the next A iterator position. Similarly, if the B iterator points to a child node and the functor returns a value with bit 1 set (e.g., 2), continue the traversal at the next B iterator position. </p><dl class="section note"><dt>Note</dt><dd>The other tree must have the same index space and fan-out factors as this tree, but it may have a different <code>ValueType</code> and a different topology. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>a tree of the same type as this tree </td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <code>template&lt;class AIterT, class BIterT&gt; int op(AIterT&amp;, BIterT&amp;)</code>, where <code>AIterT</code> and <code>BIterT</code> are any combination of a <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1RootNode.html#a01bb1bcecd7385c19f214c7dd217fb27">RootNode::ChildAllIter</a>, an <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1InternalNode.html#ace35dd5a583a8891d972fab967cf3d57">InternalNode::ChildAllIter</a> or a <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1LeafNode.html#afb0f2a243597427407203e2d697562c9">LeafNode::ChildAllIter</a> with an <code>OtherTreeType::RootNode::ChildAllIter</code>, an <code>OtherTreeType::InternalNode::ChildAllIter</code> or an <code>OtherTreeType::LeafNode::ChildAllIter</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd>Given two trees of the same type, <code>aTree</code> and <code>bTree</code>, replace leaf nodes of <code>aTree</code> with corresponding leaf nodes of <code>bTree</code>, leaving <code>bTree</code> partially empty. <div class="fragment"><div class="line"><span class="keyword">namespace </span>{</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> AIterT, <span class="keyword">typename</span> BIterT&gt;</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">int</span> stealLeafNodes(AIterT&amp; aIter, BIterT&amp; bIter)</div><div class="line">    {</div><div class="line">        <span class="keyword">typename</span> AIterT::NonConstValueType aValue;</div><div class="line">        <span class="keyword">typename</span> AIterT::ChildNodeType* aChild = aIter.probeChild(aValue);</div><div class="line">        <span class="keyword">typename</span> BIterT::NonConstValueType bValue;</div><div class="line">        <span class="keyword">typename</span> BIterT::ChildNodeType* bChild = bIter.probeChild(bValue);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespaceopenvdb_1_1v6__2.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> aLevel = aChild-&gt;getLevel(), bLevel = bChild-&gt;getLevel();</div><div class="line">        <span class="keywordflow">if</span> (aChild &amp;&amp; bChild &amp;&amp; aLevel == 0 &amp;&amp; bLevel == 0) { <span class="comment">// both are leaf nodes</span></div><div class="line">            aIter.setChild(bChild); <span class="comment">// give B&#39;s child to A</span></div><div class="line">            bIter.setValue(bValue); <span class="comment">// replace B&#39;s child with a constant tile value</span></div><div class="line">        }</div><div class="line">        <span class="comment">// Don&#39;t iterate over leaf node voxels of either A or B.</span></div><div class="line">        <span class="keywordtype">int</span> skipBranch = (aLevel == 0) ? 1 : 0;</div><div class="line">        <span class="keywordflow">if</span> (bLevel == 0) skipBranch = skipBranch | 2;</div><div class="line">        <span class="keywordflow">return</span> skipBranch;</div><div class="line">    }</div><div class="line">}</div><div class="line">{</div><div class="line">    aTree.visit2(bTree, stealLeafNodes);</div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ada17792f9a96a8fd4f9dd881840a036b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada17792f9a96a8fd4f9dd881840a036b">&#9670;&nbsp;</a></span>visit2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit2 </td>
          <td>(</td>
          <td class="paramtype">OtherTreeType &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab62bdd502fe79d887371737fe1109c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62bdd502fe79d887371737fe1109c62">&#9670;&nbsp;</a></span>visit2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit2 </td>
          <td>(</td>
          <td class="paramtype">OtherTreeType &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a3a669237d39f3536882fd6c16fb32fde">visit2()</a>, but using <code>const</code> iterators, i.e., with </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>a tree of the same type as this tree </td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <code>template&lt;class AIterT, class BIterT&gt; int op(AIterT&amp;, BIterT&amp;)</code>, where <code>AIterT</code> and <code>BIterT</code> are any combination of a <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1RootNode.html#aba3a2d9f84085e3e6b54f4358df5eb28">RootNode::ChildAllCIter</a>, an <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1InternalNode.html#aa08445224256785ccda0b3c3f8d6ffa3">InternalNode::ChildAllCIter</a> or a <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1LeafNode.html#a05f42aaba32304971f34f8fc0a355424">LeafNode::ChildAllCIter</a> with an <code>OtherTreeType::RootNode::ChildAllCIter</code>, an <code>OtherTreeType::InternalNode::ChildAllCIter</code> or an <code>OtherTreeType::LeafNode::ChildAllCIter</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a348192f35f7eb83f81b76089880a515a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348192f35f7eb83f81b76089880a515a">&#9670;&nbsp;</a></span>visit2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit2 </td>
          <td>(</td>
          <td class="paramtype">OtherTreeType &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a215bc79db1dd008c0eaa51e1831a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a215bc79db1dd008c0eaa51e1831a34">&#9670;&nbsp;</a></span>visitActiveBBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visitActiveBBox </td>
          <td>(</td>
          <td class="paramtype">BBoxOp &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use sparse traversal to call the given functor with bounding box information for all active tiles and leaf nodes or active voxels in the tree. </p>
<dl class="section note"><dt>Note</dt><dd>The bounding boxes are guaranteed to be non-overlapping. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>a functor with a templated call operator of the form <code>template&lt;Index LEVEL&gt; void operator()(const CoordBBox&amp; bbox)</code>, where <code>bbox</code> is the bounding box of either an active tile (if <code>LEVEL</code> &gt; 0), a leaf node or an active voxel. The functor must also provide a templated method of the form <code>template&lt;Index LEVEL&gt; bool descent()</code> that returns <code>false</code> if bounding boxes below the specified tree level are not to be visited. In such cases of early tree termination, a bounding box is instead derived from each terminating child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd>Visit and process all active tiles and leaf nodes in a tree, but don't descend to the active voxels. The smallest bounding boxes that will be visited are those of leaf nodes or level-1 active tiles. <div class="fragment"><div class="line">{</div><div class="line">    <span class="keyword">struct </span>ProcessTilesAndLeafNodes {</div><div class="line">        <span class="comment">// Descend to leaf nodes, but no further.</span></div><div class="line">        <span class="keyword">template</span>&lt;Index LEVEL&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span> descent() { <span class="keywordflow">return</span> LEVEL &gt; 0; }</div><div class="line">        <span class="comment">// Use this version to descend to voxels:</span></div><div class="line">        <span class="comment">//template&lt;Index LEVEL&gt; inline bool descent() { return true; }</span></div><div class="line"></div><div class="line">        <span class="keyword">template</span>&lt;Index LEVEL&gt;</div><div class="line">        <span class="keyword">inline</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> CoordBBox &amp;bbox) {</div><div class="line">            <span class="keywordflow">if</span> (LEVEL &gt; 0) {</div><div class="line">                <span class="comment">// code to process an active tile</span></div><div class="line">            } <span class="keywordflow">else</span> {</div><div class="line">                <span class="comment">// code to process a leaf node</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    };</div><div class="line">    ProcessTilesAndLeafNodes op;</div><div class="line">    aTree.visitActiveBBox(op);</div><div class="line">}</div></div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See also</dt><dd>openvdb/unittest/TestTree.cc for another example. </dd></dl>

</div>
</div>
<a id="a39a2211a02fb606e611d3ff5bbd6f50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a2211a02fb606e611d3ff5bbd6f50c">&#9670;&nbsp;</a></span>voxelizeActiveTiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void voxelizeActiveTiles </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Densify active tiles, i.e., replace them with leaf-level active voxels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threaded</td><td>if true, this operation is multi-threaded (over the internal nodes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This method can explode the tree's memory footprint, especially if it contains active tiles at the upper levels (in particular the root level)!</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#abb399cd065108e53e7b65612e74372a5" title="Set all voxels within a given axis-aligned box to a constant value and ensure that those voxels are a...">denseFill()</a> </dd></dl>

</div>
</div>
<a id="a1a50e37a4ebc77e9ed095c689ab694f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a50e37a4ebc77e9ed095c689ab694f3">&#9670;&nbsp;</a></span>writeBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeBuffers </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveFloatAsHalf</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write out all data buffers for this tree. </p>

<p>Implements <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#a4aad71ea53ca3126b0c8f05919e56f7b">TreeBase</a>.</p>

</div>
</div>
<a id="a1aba66443ac6b0c138ae069f85d9d804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aba66443ac6b0c138ae069f85d9d804">&#9670;&nbsp;</a></span>writeTopology()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeTopology </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveFloatAsHalf</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the tree topology to a stream. </p>
<p>This will write the tree structure and tile values, but not voxel data. </p>

<p>Reimplemented from <a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1TreeBase.html#a14dc8ed931e8847ff2da133d1c5f2699">TreeBase</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a33812eef2746f526e18a7d13ad9d0eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33812eef2746f526e18a7d13ad9d0eb3">&#9670;&nbsp;</a></span>DEPTH</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceopenvdb_1_1v6__2.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> DEPTH = RootNodeType::LEVEL + 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f395a4d4c40770f12f1ac8e08fdfbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f395a4d4c40770f12f1ac8e08fdfbda">&#9670;&nbsp;</a></span>mAccessorRegistry</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#afa1bfe3003db77ed8d1fa5ddac9da77d">AccessorRegistry</a> mAccessorRegistry</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a134837ab866ef110faba3311e77acd2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134837ab866ef110faba3311e77acd2b">&#9670;&nbsp;</a></span>mConstAccessorRegistry</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a8d92c2a1286b08be885d1c1ceedfba74">ConstAccessorRegistry</a> mConstAccessorRegistry</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a45a3cfd69ab5d6507b191bfe16ad3866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a3cfd69ab5d6507b191bfe16ad3866">&#9670;&nbsp;</a></span>mRoot</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1tree_1_1Tree.html#a2bfd3918f8d5734228a8a97392a91176">RootNodeType</a> mRoot</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc8fe71ac3494d1f468e2fc0ece4ca34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8fe71ac3494d1f468e2fc0ece4ca34">&#9670;&nbsp;</a></span>sTreeTypeName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tbb::atomic&lt; const <a class="el" href="namespaceopenvdb_1_1v6__2.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> * &gt; sTreeTypeName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Tree_8h_source.html">Tree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
