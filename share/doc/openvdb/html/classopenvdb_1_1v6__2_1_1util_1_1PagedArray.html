<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: PagedArray&lt; ValueT, Log2PageSize &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">6.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v6__2.html">v6_2</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v6__2_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html">PagedArray</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PagedArray&lt; ValueT, Log2PageSize &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Concurrent, page-based, dynamically-sized linear data structure with O(1) random access and STL-compliant iterators. It is primarily intended for applications that concurrently insert (a possibly unkown number of) elements into a dynamically growing linear array, and fast random access to said elements.  
 <a href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PagedArray_8h_source.html">PagedArray.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1Iterator.html">Iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1Page.html">Page</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a72ced3f4f821016da17c4ecd262e8b03"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> = ValueT</td></tr>
<tr class="separator:a72ced3f4f821016da17c4ecd262e8b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac662067233f2ff94261b81bafac2b1e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#ac662067233f2ff94261b81bafac2b1e6">Ptr</a> = <a class="el" href="namespaceopenvdb_1_1v6__2.html#ad71c1f3b8d46b57fd328d48cee283c1f">SharedPtr</a>&lt; <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html">PagedArray</a> &gt;</td></tr>
<tr class="separator:ac662067233f2ff94261b81bafac2b1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a53d94f3afe55677c30f923898e0c85e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a53d94f3afe55677c30f923898e0c85e3">PagedArray</a> ()</td></tr>
<tr class="memdesc:a53d94f3afe55677c30f923898e0c85e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a53d94f3afe55677c30f923898e0c85e3">More...</a><br /></td></tr>
<tr class="separator:a53d94f3afe55677c30f923898e0c85e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d53e13fd82dcd47d234226100469da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#aa6d53e13fd82dcd47d234226100469da">~PagedArray</a> ()</td></tr>
<tr class="memdesc:aa6d53e13fd82dcd47d234226100469da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor removed all allocated pages.  <a href="#aa6d53e13fd82dcd47d234226100469da">More...</a><br /></td></tr>
<tr class="separator:aa6d53e13fd82dcd47d234226100469da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266b3984ff84343231b5c7aad18a9d70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a266b3984ff84343231b5c7aad18a9d70">PagedArray</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html">PagedArray</a> &amp;)=delete</td></tr>
<tr class="separator:a266b3984ff84343231b5c7aad18a9d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be569554009a70ee2295d93fd64b667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html">PagedArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a2be569554009a70ee2295d93fd64b667">operator=</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html">PagedArray</a> &amp;)=delete</td></tr>
<tr class="separator:a2be569554009a70ee2295d93fd64b667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafda3d7e372dc7bcbb6d4177b9fbee3f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#aafda3d7e372dc7bcbb6d4177b9fbee3f">push_back</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:aafda3d7e372dc7bcbb6d4177b9fbee3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread safe insertion, adds a new element at the end and increases the container size by one and returns the linear offset for the inserted element.  <a href="#aafda3d7e372dc7bcbb6d4177b9fbee3f">More...</a><br /></td></tr>
<tr class="separator:aafda3d7e372dc7bcbb6d4177b9fbee3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db49bee5258957acd0317c8d4342fb3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a2db49bee5258957acd0317c8d4342fb3">push_back_unsafe</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a2db49bee5258957acd0317c8d4342fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slightly faster than the thread-safe push_back above.  <a href="#a2db49bee5258957acd0317c8d4342fb3">More...</a><br /></td></tr>
<tr class="separator:a2db49bee5258957acd0317c8d4342fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f16304f80b6fb253c7b0ead3e16dd18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a5f16304f80b6fb253c7b0ead3e16dd18">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a5f16304f80b6fb253c7b0ead3e16dd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the page table to fix the current size.  <a href="#a5f16304f80b6fb253c7b0ead3e16dd18">More...</a><br /></td></tr>
<tr class="separator:a5f16304f80b6fb253c7b0ead3e16dd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace71b58daf79e5ba3a3b54391106015a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#ace71b58daf79e5ba3a3b54391106015a">operator[]</a> (size_t i)</td></tr>
<tr class="memdesc:ace71b58daf79e5ba3a3b54391106015a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value at the specified offset.  <a href="#ace71b58daf79e5ba3a3b54391106015a">More...</a><br /></td></tr>
<tr class="separator:ace71b58daf79e5ba3a3b54391106015a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db924b63a0431aaa3a9670d21c2eda1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a9db924b63a0431aaa3a9670d21c2eda1">operator[]</a> (size_t i) const</td></tr>
<tr class="memdesc:a9db924b63a0431aaa3a9670d21c2eda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const-reference to the value at the specified offset.  <a href="#a9db924b63a0431aaa3a9670d21c2eda1">More...</a><br /></td></tr>
<tr class="separator:a9db924b63a0431aaa3a9670d21c2eda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6adf5091670b306e0669292ecfece5b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a6adf5091670b306e0669292ecfece5b8">fill</a> (const <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;v)</td></tr>
<tr class="memdesc:a6adf5091670b306e0669292ecfece5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all elements in the page table to the specified value.  <a href="#a6adf5091670b306e0669292ecfece5b8">More...</a><br /></td></tr>
<tr class="separator:a6adf5091670b306e0669292ecfece5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7480dfb0409914fda2134576f62d88b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#ab7480dfb0409914fda2134576f62d88b">copy</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> *p, size_t count) const</td></tr>
<tr class="memdesc:ab7480dfb0409914fda2134576f62d88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first <em>count</em> values in this PageArray into a raw c-style array, assuming it to be at least <em>count</em> elements long.  <a href="#ab7480dfb0409914fda2134576f62d88b">More...</a><br /></td></tr>
<tr class="separator:ab7480dfb0409914fda2134576f62d88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eae0a8edb46251d6f54095daee665ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a2eae0a8edb46251d6f54095daee665ec">copy</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> *p) const</td></tr>
<tr class="separator:a2eae0a8edb46251d6f54095daee665ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514affe27cc623fc5dccf1bf4648eb2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a514affe27cc623fc5dccf1bf4648eb2a">resize</a> (size_t <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a259cb5a711406a8c3e5d937eb9350cca">size</a>)</td></tr>
<tr class="memdesc:a514affe27cc623fc5dccf1bf4648eb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize this array to the specified size.  <a href="#a514affe27cc623fc5dccf1bf4648eb2a">More...</a><br /></td></tr>
<tr class="separator:a514affe27cc623fc5dccf1bf4648eb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9027f383daa2bb7bc9078f5f98858d47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a9027f383daa2bb7bc9078f5f98858d47">resize</a> (size_t <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a259cb5a711406a8c3e5d937eb9350cca">size</a>, const <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;v)</td></tr>
<tr class="memdesc:a9027f383daa2bb7bc9078f5f98858d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize this array to the specified size and initialize all values to <em>v</em>.  <a href="#a9027f383daa2bb7bc9078f5f98858d47">More...</a><br /></td></tr>
<tr class="separator:a9027f383daa2bb7bc9078f5f98858d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259cb5a711406a8c3e5d937eb9350cca"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a259cb5a711406a8c3e5d937eb9350cca">size</a> () const</td></tr>
<tr class="memdesc:a259cb5a711406a8c3e5d937eb9350cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in this array.  <a href="#a259cb5a711406a8c3e5d937eb9350cca">More...</a><br /></td></tr>
<tr class="separator:a259cb5a711406a8c3e5d937eb9350cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7223528283cd4e5872e0cc716bf9bd9d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a7223528283cd4e5872e0cc716bf9bd9d">capacity</a> () const</td></tr>
<tr class="memdesc:a7223528283cd4e5872e0cc716bf9bd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of elements that this array can contain without allocating more memory pages.  <a href="#a7223528283cd4e5872e0cc716bf9bd9d">More...</a><br /></td></tr>
<tr class="separator:a7223528283cd4e5872e0cc716bf9bd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cde563443a9855088851862612451f9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a6cde563443a9855088851862612451f9">freeCount</a> () const</td></tr>
<tr class="memdesc:a6cde563443a9855088851862612451f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of additional elements that can be added to this array without allocating more memory pages.  <a href="#a6cde563443a9855088851862612451f9">More...</a><br /></td></tr>
<tr class="separator:a6cde563443a9855088851862612451f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491448507f009e86efb97e3188583e37"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a491448507f009e86efb97e3188583e37">pageCount</a> () const</td></tr>
<tr class="memdesc:a491448507f009e86efb97e3188583e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of allocated memory pages.  <a href="#a491448507f009e86efb97e3188583e37">More...</a><br /></td></tr>
<tr class="separator:a491448507f009e86efb97e3188583e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fad25577340b7b31df24025314a844"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a11fad25577340b7b31df24025314a844">memUsage</a> () const</td></tr>
<tr class="memdesc:a11fad25577340b7b31df24025314a844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the memory footprint of this array in bytes.  <a href="#a11fad25577340b7b31df24025314a844">More...</a><br /></td></tr>
<tr class="separator:a11fad25577340b7b31df24025314a844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#acf82f9b2937375c7b1cf3dccb3df3312">isEmpty</a> () const</td></tr>
<tr class="memdesc:acf82f9b2937375c7b1cf3dccb3df3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the container contains no elements.  <a href="#acf82f9b2937375c7b1cf3dccb3df3312">More...</a><br /></td></tr>
<tr class="separator:acf82f9b2937375c7b1cf3dccb3df3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723fd7d55551ebb23154d15baeedbcf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a723fd7d55551ebb23154d15baeedbcf3">isPartiallyFull</a> () const</td></tr>
<tr class="memdesc:a723fd7d55551ebb23154d15baeedbcf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the page table is partially full, i.e. the last non-empty page contains less than <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#afa3a6d6e461b89bd214b04bb6ed883a6" title="Return the number of elements per memory page. ">pageSize()</a> elements.  <a href="#a723fd7d55551ebb23154d15baeedbcf3">More...</a><br /></td></tr>
<tr class="separator:a723fd7d55551ebb23154d15baeedbcf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bb3912a3ce86b15842e79d0b421204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>
<tr class="memdesc:ac8bb3912a3ce86b15842e79d0b421204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the array and delete all pages.  <a href="#ac8bb3912a3ce86b15842e79d0b421204">More...</a><br /></td></tr>
<tr class="separator:ac8bb3912a3ce86b15842e79d0b421204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2387033802383edbdc95f9bbb12a707e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a2387033802383edbdc95f9bbb12a707e">begin</a> ()</td></tr>
<tr class="memdesc:a2387033802383edbdc95f9bbb12a707e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a non-const iterator pointing to the first element.  <a href="#a2387033802383edbdc95f9bbb12a707e">More...</a><br /></td></tr>
<tr class="separator:a2387033802383edbdc95f9bbb12a707e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45dae688fc5d8983727abffa4389003"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#ab45dae688fc5d8983727abffa4389003">end</a> ()</td></tr>
<tr class="memdesc:ab45dae688fc5d8983727abffa4389003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a non-const iterator pointing to the past-the-last element.  <a href="#ab45dae688fc5d8983727abffa4389003">More...</a><br /></td></tr>
<tr class="separator:ab45dae688fc5d8983727abffa4389003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fdc9eea42b6975cdc835bb2e08810e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a47fdc9eea42b6975cdc835bb2e08810e">sort</a> ()</td></tr>
<tr class="memdesc:a47fdc9eea42b6975cdc835bb2e08810e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel sort of all the elements in ascending order.  <a href="#a47fdc9eea42b6975cdc835bb2e08810e">More...</a><br /></td></tr>
<tr class="separator:a47fdc9eea42b6975cdc835bb2e08810e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562fe73ea409de2947247a52a685a5ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a562fe73ea409de2947247a52a685a5ef">invSort</a> ()</td></tr>
<tr class="memdesc:a562fe73ea409de2947247a52a685a5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel sort of all the elements in descending order.  <a href="#a562fe73ea409de2947247a52a685a5ef">More...</a><br /></td></tr>
<tr class="separator:a562fe73ea409de2947247a52a685a5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07534f9ba83f95d11ce49c4ef4d5ce4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#ac07534f9ba83f95d11ce49c4ef4d5ce4">merge</a> (<a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html">PagedArray</a> &amp;other)</td></tr>
<tr class="memdesc:ac07534f9ba83f95d11ce49c4ef4d5ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer all the elements (and pages) from the other array to this array.  <a href="#ac07534f9ba83f95d11ce49c4ef4d5ce4">More...</a><br /></td></tr>
<tr class="separator:ac07534f9ba83f95d11ce49c4ef4d5ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76e7240cdf93cfe932eb4ebee0711e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#ae76e7240cdf93cfe932eb4ebee0711e7">print</a> (std::ostream &amp;os=std::cout) const</td></tr>
<tr class="memdesc:ae76e7240cdf93cfe932eb4ebee0711e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print information for debugging.  <a href="#ae76e7240cdf93cfe932eb4ebee0711e7">More...</a><br /></td></tr>
<tr class="separator:ae76e7240cdf93cfe932eb4ebee0711e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a98b1109a9006f8cc7d4566146a3bd737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a98b1109a9006f8cc7d4566146a3bd737">cbegin</a> () const</td></tr>
<tr class="memdesc:a98b1109a9006f8cc7d4566146a3bd737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator pointing to the first element.  <a href="#a98b1109a9006f8cc7d4566146a3bd737">More...</a><br /></td></tr>
<tr class="separator:a98b1109a9006f8cc7d4566146a3bd737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fee900c7aee90671038c79225bf8ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#ad5fee900c7aee90671038c79225bf8ec">begin</a> () const</td></tr>
<tr class="memdesc:ad5fee900c7aee90671038c79225bf8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator pointing to the first element.  <a href="#ad5fee900c7aee90671038c79225bf8ec">More...</a><br /></td></tr>
<tr class="separator:ad5fee900c7aee90671038c79225bf8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a02fd29b6dc3e21fbe4484362d85893bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a02fd29b6dc3e21fbe4484362d85893bc">cend</a> () const</td></tr>
<tr class="memdesc:a02fd29b6dc3e21fbe4484362d85893bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator pointing to the past-the-last element.  <a href="#a02fd29b6dc3e21fbe4484362d85893bc">More...</a><br /></td></tr>
<tr class="separator:a02fd29b6dc3e21fbe4484362d85893bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b6e2a03c835ca5d658a1f16acbaa9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a69b6e2a03c835ca5d658a1f16acbaa9c">end</a> () const</td></tr>
<tr class="memdesc:a69b6e2a03c835ca5d658a1f16acbaa9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator pointing to the past-the-last element.  <a href="#a69b6e2a03c835ca5d658a1f16acbaa9c">More...</a><br /></td></tr>
<tr class="separator:a69b6e2a03c835ca5d658a1f16acbaa9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a532f53d8ad34787bf9734b63665a9ef9"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a532f53d8ad34787bf9734b63665a9ef9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a532f53d8ad34787bf9734b63665a9ef9">sort</a> (Functor func)</td></tr>
<tr class="memdesc:a532f53d8ad34787bf9734b63665a9ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel sort of all the elements based on a custom functor with the api:  <a href="#a532f53d8ad34787bf9734b63665a9ef9">More...</a><br /></td></tr>
<tr class="separator:a532f53d8ad34787bf9734b63665a9ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad9ed7a677da4265c8ec80a525783c7f0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#ac662067233f2ff94261b81bafac2b1e6">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#ad9ed7a677da4265c8ec80a525783c7f0">create</a> ()</td></tr>
<tr class="memdesc:ad9ed7a677da4265c8ec80a525783c7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a shared pointer to a new instance of this class.  <a href="#ad9ed7a677da4265c8ec80a525783c7f0">More...</a><br /></td></tr>
<tr class="separator:ad9ed7a677da4265c8ec80a525783c7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3a6d6e461b89bd214b04bb6ed883a6"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#afa3a6d6e461b89bd214b04bb6ed883a6">pageSize</a> ()</td></tr>
<tr class="memdesc:afa3a6d6e461b89bd214b04bb6ed883a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements per memory page.  <a href="#afa3a6d6e461b89bd214b04bb6ed883a6">More...</a><br /></td></tr>
<tr class="separator:afa3a6d6e461b89bd214b04bb6ed883a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20079d9af0877028f05572c5eda297a4"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a20079d9af0877028f05572c5eda297a4">log2PageSize</a> ()</td></tr>
<tr class="memdesc:a20079d9af0877028f05572c5eda297a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return log2 of the number of elements per memory page.  <a href="#a20079d9af0877028f05572c5eda297a4">More...</a><br /></td></tr>
<tr class="separator:a20079d9af0877028f05572c5eda297a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:afc867e0705ff7ee57a5a4be9bb466aa8"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#afc867e0705ff7ee57a5a4be9bb466aa8">ValueBuffer</a></td></tr>
<tr class="separator:afc867e0705ff7ee57a5a4be9bb466aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt;<br />
class openvdb::v6_2::util::PagedArray&lt; ValueT, Log2PageSize &gt;</h3>

<p>Concurrent, page-based, dynamically-sized linear data structure with O(1) random access and STL-compliant iterators. It is primarily intended for applications that concurrently insert (a possibly unkown number of) elements into a dynamically growing linear array, and fast random access to said elements. </p>
<dl class="section note"><dt>Note</dt><dd>Multiple threads can grow the page-table and push_back new elements concurrently. A <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a> provides accelerated and threadsafe push_back at the cost of potentially re-ordering elements (when multiple instances are used).</dd></dl>
<p>This data structure employes contiguous pages of elements (a std::deque) which avoids moving data when the capacity is out-grown and new pages are allocated. The size of the pages can be controlled with the Log2PageSize template parameter (defaults to 1024 elements of type ValueT).</p>
<p>There are three fundamentally different ways to insert elements to this container - each with different advanteges and disadvanteges.</p>
<p>The simplest way to insert elements is to use <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#aafda3d7e372dc7bcbb6d4177b9fbee3f" title="Thread safe insertion, adds a new element at the end and increases the container size by one and retu...">PagedArray::push_back</a> e.g. </p><div class="fragment"><div class="line">PagedArray&lt;size_t&gt; array;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;100000; ++i) array.push_back(i);</div></div><!-- fragment --><p> or with TBB task-based multi-threading </p><div class="fragment"><div class="line">PagedArray&lt;size_t&gt; array;</div><div class="line">tbb::parallel_for(</div><div class="line">    tbb::blocked_range&lt;size_t&gt;(0, 10000, array.pageSize()),</div><div class="line">    [&amp;array](<span class="keyword">const</span> tbb::blocked_range&lt;size_t&gt;&amp; range) {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=range.begin(); i!=range.end(); ++i) array.push_back(i);</div><div class="line">    }</div><div class="line">);</div></div><!-- fragment --><p> <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#aafda3d7e372dc7bcbb6d4177b9fbee3f" title="Thread safe insertion, adds a new element at the end and increases the container size by one and retu...">PagedArray::push_back</a> has the advantage that it's thread-safe and preserves the ordering of the inserted elements. In fact it returns the linear offset to the added element which can then be used for fast O(1) random access. The disadvantage is it's the slowest of the three different ways of inserting elements.</p>
<p>The fastest way (by far) to insert elements by means of a <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ValueBuffer.html">PagedArray::ValueBuffer</a>, e.g. </p><div class="fragment"><div class="line">PagedArray&lt;size_t&gt; array;</div><div class="line"><a class="code" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#afc867e0705ff7ee57a5a4be9bb466aa8">PagedArray&lt;size_t&gt;::ValueBuffer</a> buffer(array);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;100000; ++i) buffer.push_back(i);</div><div class="line">buffer.flush();</div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">PagedArray&lt;size_t&gt; array;</div><div class="line">{</div><div class="line">    <span class="comment">//local scope of a single thread</span></div><div class="line">    <a class="code" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#afc867e0705ff7ee57a5a4be9bb466aa8">PagedArray&lt;size_t&gt;::ValueBuffer</a> buffer(array);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;100000; ++i) buffer.push_back(i);</div><div class="line">}</div></div><!-- fragment --><p> or with TBB task-based multi-threading </p><div class="fragment"><div class="line">PagedArray&lt;size_t&gt; array;</div><div class="line">tbb::parallel_for(</div><div class="line">    tbb::blocked_range&lt;size_t&gt;(0, 10000, array.pageSize()),</div><div class="line">    [&amp;array](<span class="keyword">const</span> tbb::blocked_range&lt;size_t&gt;&amp; range) {</div><div class="line">        <a class="code" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#afc867e0705ff7ee57a5a4be9bb466aa8">PagedArray&lt;size_t&gt;::ValueBuffer</a> buffer(array);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=range.begin(); i!=range.end(); ++i) buffer.push_back(i);</div><div class="line">    }</div><div class="line">);</div></div><!-- fragment --><p> or with TBB thread-local storage for even better performance (due to fewer concurrent instantiations of partially full ValueBuffers) </p><div class="fragment"><div class="line">PagedArray&lt;size_t&gt; array;</div><div class="line"><a class="code" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#afc867e0705ff7ee57a5a4be9bb466aa8">PagedArray&lt;size_t&gt;::ValueBuffer</a> exemplar(array);<span class="comment">//dummy used for initialization</span></div><div class="line">tbb::enumerable_thread_specific&lt;PagedArray&lt;size_t&gt;::ValueBuffer&gt;</div><div class="line">    pool(exemplar);<span class="comment">//thread local storage pool of ValueBuffers</span></div><div class="line">tbb::parallel_for(</div><div class="line">    tbb::blocked_range&lt;size_t&gt;(0, 10000, array.pageSize()),</div><div class="line">    [&amp;pool](<span class="keyword">const</span> tbb::blocked_range&lt;size_t&gt;&amp; range) {</div><div class="line">        <a class="code" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#afc867e0705ff7ee57a5a4be9bb466aa8">PagedArray&lt;size_t&gt;::ValueBuffer</a> &amp;buffer = pool.local();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=range.begin(); i!=range.end(); ++i) buffer.push_back(i);</div><div class="line">    }</div><div class="line">);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> i=pool.begin(); i!=pool.end(); ++i) i-&gt;flush();</div></div><!-- fragment --><p> This technique generally outperforms <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#aafda3d7e372dc7bcbb6d4177b9fbee3f" title="Thread safe insertion, adds a new element at the end and increases the container size by one and retu...">PagedArray::push_back</a>, std::vector::push_back, std::deque::push_back and even tbb::concurrent_vector::push_back. Additionally it is thread-safe as long as each thread has it's own instance of a <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ValueBuffer.html">PagedArray::ValueBuffer</a>. The only disadvantage is the ordering of the elements is undefined if multiple instance of a <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ValueBuffer.html">PagedArray::ValueBuffer</a> are employed. This is typically the case in the context of multi-threading, where the ordering of inserts are undefined anyway. Note that a local scope can be used to guarentee that the <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a> has inserted all its elements by the time the scope ends. Alternatively the <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a> can be explicitly flushed by calling <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ValueBuffer.html#adac116554b543b7c4228c018a85882f5" title="Manually transfers the values in this buffer to the parent PagedArray. ">ValueBuffer::flush</a>.</p>
<p>The third way to insert elements is to resize the container and use random access, e.g. </p><div class="fragment"><div class="line">PagedArray&lt;int&gt; array;</div><div class="line">array.resize(100000);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;100000; ++i) array[i] = i;</div></div><!-- fragment --><p> or in terms of the random access iterator </p><div class="fragment"><div class="line">PagedArray&lt;int&gt; array;</div><div class="line">array.resize(100000);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> i=array.begin(); i!=array.end(); ++i) *i = i.pos();</div></div><!-- fragment --><p> While this approach is both fast and thread-safe it suffers from the major disadvantage that the problem size, i.e. number of elements, needs to be known in advance. If that's the case you might as well consider using std::vector or a raw c-style array! In other words the <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html" title="Concurrent, page-based, dynamically-sized linear data structure with O(1) random access and STL-compl...">PagedArray</a> is most useful in the context of applications that involve multi-threading of dynamically growing linear arrays that require fast random access. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac662067233f2ff94261b81bafac2b1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac662067233f2ff94261b81bafac2b1e6">&#9670;&nbsp;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#ac662067233f2ff94261b81bafac2b1e6">Ptr</a> =  <a class="el" href="namespaceopenvdb_1_1v6__2.html#ad71c1f3b8d46b57fd328d48cee283c1f">SharedPtr</a>&lt;<a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html">PagedArray</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72ced3f4f821016da17c4ecd262e8b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ced3f4f821016da17c4ecd262e8b03">&#9670;&nbsp;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> =  ValueT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a53d94f3afe55677c30f923898e0c85e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d94f3afe55677c30f923898e0c85e3">&#9670;&nbsp;</a></span>PagedArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html">PagedArray</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="aa6d53e13fd82dcd47d234226100469da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d53e13fd82dcd47d234226100469da">&#9670;&nbsp;</a></span>~PagedArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html">PagedArray</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor removed all allocated pages. </p>

</div>
</div>
<a id="a266b3984ff84343231b5c7aad18a9d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266b3984ff84343231b5c7aad18a9d70">&#9670;&nbsp;</a></span>PagedArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html">PagedArray</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html">PagedArray</a>&lt; ValueT, Log2PageSize &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2387033802383edbdc95f9bbb12a707e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2387033802383edbdc95f9bbb12a707e">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1Iterator.html">Iterator</a> begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a non-const iterator pointing to the first element. </p>

</div>
</div>
<a id="ad5fee900c7aee90671038c79225bf8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fee900c7aee90671038c79225bf8ec">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a> begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator pointing to the first element. </p>

</div>
</div>
<a id="a7223528283cd4e5872e0cc716bf9bd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7223528283cd4e5872e0cc716bf9bd9d">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum number of elements that this array can contain without allocating more memory pages. </p>

</div>
</div>
<a id="a98b1109a9006f8cc7d4566146a3bd737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b1109a9006f8cc7d4566146a3bd737">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a> cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator pointing to the first element. </p>

</div>
</div>
<a id="a02fd29b6dc3e21fbe4484362d85893bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fd29b6dc3e21fbe4484362d85893bc">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a> cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator pointing to the past-the-last element. </p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1Iterator.html">Iterator</a> does not point to a valid element and should not be dereferenced! </dd></dl>

</div>
</div>
<a id="ac8bb3912a3ce86b15842e79d0b421204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bb3912a3ce86b15842e79d0b421204">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements from the array and delete all pages. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe! </dd></dl>

</div>
</div>
<a id="ab7480dfb0409914fda2134576f62d88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7480dfb0409914fda2134576f62d88b">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the first <em>count</em> values in this PageArray into a raw c-style array, assuming it to be at least <em>count</em> elements long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pointer to an array that will used as the destination of the copy. </td></tr>
    <tr><td class="paramname">count</td><td>number of elements to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2eae0a8edb46251d6f54095daee665ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eae0a8edb46251d6f54095daee665ec">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9ed7a677da4265c8ec80a525783c7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ed7a677da4265c8ec80a525783c7f0">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#ac662067233f2ff94261b81bafac2b1e6">Ptr</a> create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a shared pointer to a new instance of this class. </p>

</div>
</div>
<a id="ab45dae688fc5d8983727abffa4389003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45dae688fc5d8983727abffa4389003">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1Iterator.html">Iterator</a> end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a non-const iterator pointing to the past-the-last element. </p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1Iterator.html">Iterator</a> does not point to a valid element and should not be dereferenced! </dd></dl>

</div>
</div>
<a id="a69b6e2a03c835ca5d658a1f16acbaa9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b6e2a03c835ca5d658a1f16acbaa9c">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a> end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator pointing to the past-the-last element. </p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1Iterator.html">Iterator</a> does not point to a valid element and should not be dereferenced! </dd></dl>

</div>
</div>
<a id="a6adf5091670b306e0669292ecfece5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6adf5091670b306e0669292ecfece5b8">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all elements in the page table to the specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>value to be filled in all the existing pages of this <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html" title="Concurrent, page-based, dynamically-sized linear data structure with O(1) random access and STL-compl...">PagedArray</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Multi-threaded </dd></dl>

</div>
</div>
<a id="a6cde563443a9855088851862612451f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cde563443a9855088851862612451f9">&#9670;&nbsp;</a></span>freeCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t freeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of additional elements that can be added to this array without allocating more memory pages. </p>

</div>
</div>
<a id="a562fe73ea409de2947247a52a685a5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562fe73ea409de2947247a52a685a5ef">&#9670;&nbsp;</a></span>invSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void invSort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel sort of all the elements in descending order. </p>

</div>
</div>
<a id="acf82f9b2937375c7b1cf3dccb3df3312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf82f9b2937375c7b1cf3dccb3df3312">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the container contains no elements. </p>

</div>
</div>
<a id="a723fd7d55551ebb23154d15baeedbcf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723fd7d55551ebb23154d15baeedbcf3">&#9670;&nbsp;</a></span>isPartiallyFull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isPartiallyFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the page table is partially full, i.e. the last non-empty page contains less than <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#afa3a6d6e461b89bd214b04bb6ed883a6" title="Return the number of elements per memory page. ">pageSize()</a> elements. </p>
<p>When the page table is partially full calling <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#ac07534f9ba83f95d11ce49c4ef4d5ce4" title="Transfer all the elements (and pages) from the other array to this array. ">merge()</a> or using a <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a> will rearrange the ordering of existing elements. </p>

</div>
</div>
<a id="a20079d9af0877028f05572c5eda297a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20079d9af0877028f05572c5eda297a4">&#9670;&nbsp;</a></span>log2PageSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t log2PageSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return log2 of the number of elements per memory page. </p>

</div>
</div>
<a id="a11fad25577340b7b31df24025314a844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fad25577340b7b31df24025314a844">&#9670;&nbsp;</a></span>memUsage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t memUsage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the memory footprint of this array in bytes. </p>

</div>
</div>
<a id="ac07534f9ba83f95d11ce49c4ef4d5ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07534f9ba83f95d11ce49c4ef4d5ce4">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html">PagedArray</a>&lt; ValueT, Log2PageSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer all the elements (and pages) from the other array to this array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>non-const reference to the <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html" title="Concurrent, page-based, dynamically-sized linear data structure with O(1) random access and STL-compl...">PagedArray</a> that will be merged into this <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html" title="Concurrent, page-based, dynamically-sized linear data structure with O(1) random access and STL-compl...">PagedArray</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The other <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html" title="Concurrent, page-based, dynamically-sized linear data structure with O(1) random access and STL-compl...">PagedArray</a> is empty on return.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The ordering of elements is undefined if this page table is partially full! </dd></dl>

</div>
</div>
<a id="a2be569554009a70ee2295d93fd64b667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be569554009a70ee2295d93fd64b667">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html">PagedArray</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html">PagedArray</a>&lt; ValueT, Log2PageSize &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ace71b58daf79e5ba3a3b54391106015a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace71b58daf79e5ba3a3b54391106015a">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a>&amp; operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>linear offset of the value to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This random access has constant time complexity.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is assumed that the i'th element is already allocated! </dd></dl>

</div>
</div>
<a id="a9db924b63a0431aaa3a9670d21c2eda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db924b63a0431aaa3a9670d21c2eda1">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a>&amp; operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const-reference to the value at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>linear offset of the value to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This random access has constant time complexity.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is assumed that the i'th element is already allocated! </dd></dl>

</div>
</div>
<a id="a491448507f009e86efb97e3188583e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491448507f009e86efb97e3188583e37">&#9670;&nbsp;</a></span>pageCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t pageCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of allocated memory pages. </p>

</div>
</div>
<a id="afa3a6d6e461b89bd214b04bb6ed883a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3a6d6e461b89bd214b04bb6ed883a6">&#9670;&nbsp;</a></span>pageSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t pageSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements per memory page. </p>

</div>
</div>
<a id="ae76e7240cdf93cfe932eb4ebee0711e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76e7240cdf93cfe932eb4ebee0711e7">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>std::cout</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print information for debugging. </p>

</div>
</div>
<a id="aafda3d7e372dc7bcbb6d4177b9fbee3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafda3d7e372dc7bcbb6d4177b9fbee3f">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread safe insertion, adds a new element at the end and increases the container size by one and returns the linear offset for the inserted element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to be added to this <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html" title="Concurrent, page-based, dynamically-sized linear data structure with O(1) random access and STL-compl...">PagedArray</a></td></tr>
  </table>
  </dd>
</dl>
<p>Constant time complexity. May allocate a new page. </p>

</div>
</div>
<a id="a2db49bee5258957acd0317c8d4342fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db49bee5258957acd0317c8d4342fb3">&#9670;&nbsp;</a></span>push_back_unsafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t push_back_unsafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Slightly faster than the thread-safe push_back above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to be added to this <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html" title="Concurrent, page-based, dynamically-sized linear data structure with O(1) random access and STL-compl...">PagedArray</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For best performance consider using the ValueBuffer!</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe! </dd></dl>

</div>
</div>
<a id="a514affe27cc623fc5dccf1bf4648eb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514affe27cc623fc5dccf1bf4648eb2a">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize this array to the specified size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>number of elements that this PageArray will contain.</td></tr>
  </table>
  </dd>
</dl>
<p>Will grow or shrink the page table to contain the specified number of elements. It will affect the <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a259cb5a711406a8c3e5d937eb9350cca" title="Return the number of elements in this array. ">size()</a>, iteration will go over all those elements, push_back will insert after them and operator[] can be used directly access them.</p>
<dl class="section note"><dt>Note</dt><dd>No reserve method is implemented due to efficiency concerns (especially for the <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a>) from having to deal with empty pages.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe! </dd></dl>

</div>
</div>
<a id="a9027f383daa2bb7bc9078f5f98858d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9027f383daa2bb7bc9078f5f98858d47">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize this array to the specified size and initialize all values to <em>v</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>number of elements that this PageArray will contain. </td></tr>
    <tr><td class="paramname">v</td><td>value of all the <em>size</em> values.</td></tr>
  </table>
  </dd>
</dl>
<p>Will grow or shrink the page table to contain the specified number of elements. It will affect the <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray.html#a259cb5a711406a8c3e5d937eb9350cca" title="Return the number of elements in this array. ">size()</a>, iteration will go over all those elements, push_back will insert after them and operator[] can be used directly access them.</p>
<dl class="section note"><dt>Note</dt><dd>No reserve method is implemented due to efficiency concerns (especially for the <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a>) from having to deal with empty pages.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe! </dd></dl>

</div>
</div>
<a id="a5f16304f80b6fb253c7b0ead3e16dd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f16304f80b6fb253c7b0ead3e16dd18">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce the page table to fix the current size. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe! </dd></dl>

</div>
</div>
<a id="a259cb5a711406a8c3e5d937eb9350cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259cb5a711406a8c3e5d937eb9350cca">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements in this array. </p>

</div>
</div>
<a id="a47fdc9eea42b6975cdc835bb2e08810e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fdc9eea42b6975cdc835bb2e08810e">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel sort of all the elements in ascending order. </p>

</div>
</div>
<a id="a532f53d8ad34787bf9734b63665a9ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532f53d8ad34787bf9734b63665a9ef9">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sort </td>
          <td>(</td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel sort of all the elements based on a custom functor with the api: </p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> ValueT&amp; a, <span class="keyword">const</span> ValueT&amp; b) </div></div><!-- fragment --><p> which returns true if a comes before b. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="afc867e0705ff7ee57a5a4be9bb466aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc867e0705ff7ee57a5a4be9bb466aa8">&#9670;&nbsp;</a></span>ValueBuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classopenvdb_1_1v6__2_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PagedArray_8h_source.html">PagedArray.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
